<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>木 偶</title><link>https://muou55555.github.io/</link><description>Software development and architecture blog</description><atom:link href="https://muou55555.github.io/feeds/muou.rss.xml" rel="self"></atom:link><lastBuildDate>Thu, 14 Jan 2016 15:25:00 +0800</lastBuildDate><item><title>Markdown中使用MathJax引擎显示数学公式</title><link>https://muou55555.github.io/content/articles/2016/01/14/markdown_math/</link><description>&lt;script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"&gt;&lt;/script&gt;

&lt;p&gt;在工作中，我们经常会用到一些数学公式，如何把这些数学公式显示在文章中，可以利用Markdown+MathJax完成在文章中显示各种数学公式。&lt;br&gt;
Markdown的语法网上有很多，这里就不做重述。&lt;br&gt;
MathJax是一款运行在浏览器中的开源的数学符号渲染引擎，使用MathJax可以方便的在浏览器中显示数学公式，不需要使用图片。可以解析LaTex、MathML和ASCIIMathMl的标记语言。&lt;br&gt;&lt;/p&gt;
&lt;h3&gt;参考资料&lt;/h3&gt;
&lt;p&gt;MathJax官网: &lt;a href="https://www.mathjax.org/"&gt;https://www.mathjax.org/&lt;/a&gt;  &lt;br&gt;
MathJax源码: &lt;a href="https://github.com/mathjax/"&gt;https://github.com/mathjax/&lt;/a&gt;  &lt;br&gt;
&lt;a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference"&gt;MathJax使用说明&lt;/a&gt;&lt;br&gt;
Latex在线编辑器: &lt;a href="http://latex.codecogs.com/eqneditor/editor.php"&gt;http://latex.codecogs.com/eqneditor/editor.php&lt;/a&gt; &lt;br&gt;&lt;/p&gt;
&lt;h3&gt;使用方法&lt;/h3&gt;
&lt;h4&gt;规则&lt;/h4&gt;
&lt;p&gt;显示方式分为两种，一种是行内，写在&lt;code&gt;\...\&lt;/code&gt;内；另一种是行间,写在&lt;code&gt;$$...$$&lt;/code&gt;&lt;br&gt;
&lt;code&gt;Tips:&lt;/code&gt; 我试了下在markdown中写在&lt;code&gt;$$...$$&lt;/code&gt;只能在一行中显示，需要在多行时显示，可以放在&lt;code&gt;&amp;lt;div&amp;gt;...&amp;lt;/div&amp;gt;&lt;/code&gt;之间。&lt;br&gt;&lt;/p&gt;
&lt;h4&gt;步骤&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;在文档头部加入&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; &lt;span class="nt"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;text/javascript&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;然后可以使用Latex在线编辑器进行数学公式编写，然后把结果复制到markdown中即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;行间
$$x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}$$
行内 \(x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}\)&lt;/p&gt;
&lt;p&gt;行间
$$\lim_{n \rightarrow +\infty} \frac{1}{n(n+1)}$$
行内 \(lim_{n \rightarrow +\infty} \frac{1}{n(n+1)}\)&lt;/p&gt;
&lt;p&gt;带括号的矩阵&lt;/p&gt;
&lt;div&gt;
\begin{pmatrix}
a_{11} &amp; \cdots &amp; a_{1n}\\
\vdots &amp; \ddots &amp; \vdots\\
a_{m1} &amp; \cdots &amp; a_{mn}
\end{pmatrix}
&lt;/div&gt;

&lt;div&gt;
\begin{pmatrix}
1&amp;0\\
0&amp;1
\end{pmatrix}
&lt;/div&gt;

&lt;p&gt;不带括号的&lt;/p&gt;
&lt;div&gt;
\begin{matrix} 
1 &amp; x &amp; x^2 \\
1 &amp; y &amp; y^2 \\
1 &amp; z &amp; z^2 
\end{matrix}
&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">muou</dc:creator><pubDate>Thu, 14 Jan 2016 15:25:00 +0800</pubDate><guid>tag:muou55555.github.io,2016-01-14:content/articles/2016/01/14/markdown_math/</guid><category>Markdown</category></item><item><title>利用libnet进行TCP会话劫持</title><link>https://muou55555.github.io/content/articles/2016/01/12/tcphijack/</link><description>&lt;h3&gt;相关知识&lt;/h3&gt;
&lt;p&gt;会话劫持（Session Hijack）: 就是结合了嗅探以及欺骗技术在内的攻击手段。例如，在一次正常的会话过程当中，攻击者作为第三方参与到其中，他可以在正常数据包中插入恶意数据，也可以在双方的会话当中进行监听，甚至可以是代替某一方主机接管会话。
&lt;br&gt;
可以把会话劫持攻击分为两种类型:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中间人攻击(Man In The Middle，简称MITM)&lt;/li&gt;
&lt;li&gt;注射式攻击（Injection）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;既然是进行TCP劫持，则先要对TCP/IP协议相关知识有个初步的了解。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP/IP数据封装&lt;br&gt;
&lt;div&gt; 
&lt;img style="border-radius: 1%; display: block;" width = "350px" height = "350px" src="/images/http/tcpipdata.png" alt="1"/&gt;
&lt;/div&gt; &lt;/li&gt;
&lt;li&gt;IP数据包格式&lt;br&gt;
&lt;div&gt; 
&lt;img style="border-radius: 1%; display: block;" width = "350px" height = "350px" src="/images/http/ipdata.gif" alt="1"/&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;TCP建立连接过程&lt;br&gt;
&lt;div&gt; 
&lt;img style="border-radius: 1%; display: block;" width = "350px" height = "300px" src="/images/http/tcpcnt.jpg" alt="1"/&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;原理&lt;/h3&gt;
&lt;h4&gt;注射式攻击&lt;/h4&gt;
&lt;p&gt;这种方式的会话劫持比中间人攻击实现起来简单一些，它不会改变会话双方的通讯流，而是在双方正常的通讯中流插入恶意数据。在注射式攻击中，需要实现两种技术：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IP欺骗；&lt;/li&gt;
&lt;li&gt;预测TCP序列号。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于IP欺骗，有两种情况需要用到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;隐藏自己的IP地址；&lt;/li&gt;
&lt;li&gt;利用两台机器之间的信任关系实施入侵。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Unix/Linux平台上，可以直接使用Socket构造IP包，在IP头中填上虚假的IP地址，但需要root权限；在Windows平台上，不能使用Winsock，需要使用Winpacp（也可以使用Libnet）。例如在Linux系统，首先打开一个Raw Socket（原始套接字），然后自己编写IP头及其他数据。
TCP协议的注射式会话劫持，攻击者应先采用嗅探技术对目标进行监听，然后从监听到的信息中构造出正确的序列号，如果不这样，你就必须先猜测目标的ISN（初始序列号），这样无形中对会话劫持加大了难度。&lt;/p&gt;
&lt;h4&gt;中间人攻击MITM&lt;/h4&gt;
&lt;p&gt;要想正确的实施中间人攻击，攻击者首先需要使用ARP欺骗或DNS欺骗，将会话双方的通讯流暗中改变，而这种改变对于会话双方来说是一个完全透明的代理，可以得到一切想知道的信息，甚至是利用一些有缺陷的加密协议来实现。 &lt;/p&gt;
&lt;h3&gt;libnet&lt;/h3&gt;
&lt;p&gt;libnet是一个开源的接口函数库，主要用C语言实现，提供了底层网络数据包的构造、处理和发送功能。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tips&lt;/code&gt; 实际实现过程中，会用libpcap进行监控，用libnet进行构造数据包&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;libnet主要流程
&lt;div&gt; 
&lt;img style="border-radius: 1%; display: block;" width = "400px" height = "260px" src="/images/http/libnet.png" alt="1"/&gt;
&lt;/div&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;源码&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下载地址: &lt;a href="http://sourceforge.net/projects/libnet-dev/"&gt;libnet&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;DEMO部分代码&lt;/h3&gt;
&lt;p&gt;对http会话协议报文的篡改，实现基本的302重定向功能&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="c1"&gt;//初始化libnet，每个线程一个libnet &lt;/span&gt;
    &lt;span class="n"&gt;init_thread_libnet&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="c1"&gt;//http重定向&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ip_head&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;protocol&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;IPPROTO_TCP&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;tcp_head&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;dest&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;HTTP_PORT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;u_int8_t&lt;/span&gt; &lt;span class="n"&gt;tcp_flags&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;libnet_tcp_hdr&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;tcp_head&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;th_flags&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tcp_flags&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;TH_SYN&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nl"&gt;TODO:&lt;/span&gt; &lt;span class="err"&gt;回复一个&lt;/span&gt;&lt;span class="n"&gt;syn&lt;/span&gt; &lt;span class="n"&gt;ack&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tcp_flags&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TH_ACK&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;TH_SYN&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nl"&gt;TODO:&lt;/span&gt; &lt;span class="err"&gt;伪造&lt;/span&gt;&lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="err"&gt;响应报文。这里是&lt;/span&gt;&lt;span class="mi"&gt;302&lt;/span&gt;&lt;span class="err"&gt;重定向&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tcp_flags&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TH_FIN&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;TH_RST&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nl"&gt;TODO:&lt;/span&gt; &lt;span class="err"&gt;结束链接&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;伪造所用的http head&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;static&lt;/span&gt; &lt;span class="nx"&gt;u_int8_t&lt;/span&gt; &lt;span class="nx"&gt;httphead_t&lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; =
&amp;quot;HTTP/1.0 302 Found\n&amp;quot;
&amp;quot;Location: %s\n&amp;quot;
&amp;quot;Connection:close\n\n&amp;quot;
&amp;quot;&lt;span class="nt"&gt;&amp;lt;html&amp;gt;&lt;/span&gt;\n\t&lt;span class="nt"&gt;&amp;lt;head&amp;gt;&lt;/span&gt;\n\t\t&lt;span class="nt"&gt;&amp;lt;meta&lt;/span&gt; &lt;span class="na"&gt;http-equiv=&lt;/span&gt;&lt;span class="s"&gt;\&amp;quot;Refresh\&amp;quot;content=\&amp;quot;0;&amp;quot;&lt;/span&gt;
&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="na"&gt;url=&lt;/span&gt;&lt;span class="s"&gt;%s\&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;\n\t&lt;span class="nt"&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;\n&lt;span class="nt"&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;\n&amp;quot;;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;结束语&lt;/h3&gt;
&lt;p&gt;只有在了解别人攻击手段之后，我们才能做好网络安全的防范措施。&lt;br&gt;
后续会在研究https会话劫持技术&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">muou</dc:creator><pubDate>Tue, 12 Jan 2016 22:25:00 +0800</pubDate><guid>tag:muou55555.github.io,2016-01-12:content/articles/2016/01/12/tcphijack/</guid><category>Http</category><category>Tcp</category></item><item><title>How to C in 2016</title><link>https://muou55555.github.io/content/articles/2016/01/11/howtoc/</link><description>&lt;p&gt;&lt;code&gt;Forward link&lt;/code&gt; &lt;a href="https://matt.sh/howto-c"&gt;https://matt.sh/howto-c&lt;/a&gt;&lt;br&gt;
This is a draft I wrote in early 2015 and never got around to publishing. Here's the mostly unpolished version because it wasn't doing anybody any good sitting in my drafts folder. The simplest change was updating year 2015 to 2016 at publication time.&lt;/p&gt;
&lt;p&gt;Feel free to submit fixes/improvements/complaints as necessary. -Matt&lt;/p&gt;
&lt;p&gt;Adrián Arroyo Calle provides a Spanish translation at ?Cómo programar en C (en 2016)?&lt;/p&gt;
&lt;p&gt;Keith Thompson provides a nice set of corrections and alternative opinions at howto-c-response.&lt;/p&gt;
&lt;p&gt;Now on to the article...&lt;/p&gt;
&lt;p&gt;The first rule of C is don't write C if you can avoid it.&lt;/p&gt;
&lt;p&gt;If you must write in C, you should follow modern rules.&lt;/p&gt;
&lt;p&gt;C has been around since the early 1970s. People have "learned C" at various points during its evolution, but knowledge usually get stuck after learning, so everybody has a different set of things they believe about C based on the year(s) they first started learning.&lt;/p&gt;
&lt;p&gt;It's important to not remain stuck in your "things I learned in the 80s/90s" mindset of C development.&lt;/p&gt;
&lt;p&gt;This page assumes you are on a modern platform conforming to modern standards and you have no excessive legacy compatibility requirements. We shouldn't be globally tied to ancient standards just because some companies refuse to upgrade 20 year old systems.&lt;/p&gt;
&lt;p&gt;Preflight
Standard c99 (c99 means "C Standard from 1999"; c11 means "C Standard from 2011", so 11 &amp;gt; 99).&lt;/p&gt;
&lt;p&gt;clang, default
clang uses an extended version of C11 by default (GNU C11 mode), so no extra options are needed for modern features.
If you want standard C11, you need to specify -std=c11; if you want standard C99, use -std=c99.
clang compiles your source files faster than gcc
gcc requires you specify -std=c99 or -std=c11
gcc builds source files slower than clang, but sometimes generates faster code. Performance comparisons and regression testings are important.
gcc-5 defaults to GNU C11 mode (same as clang), but if you need exactly c11 or c99, you should still specify -std=c11 or -std=c99.
Optimizations&lt;/p&gt;
&lt;p&gt;-O2, -O3
generally you want -O2, but sometimes you want -O3. Test under both levels (and across compilers) then keep the best performing binaries.
-Os
-Os helps if your concern is cache efficiency (which it should be)
Warnings&lt;/p&gt;
&lt;p&gt;-Wall -Wextra -pedantic
newer compiler versions have -Wpedantic, but they still accept the ancient -pedantic as well for wider backwards compatibility.
during testing you should add -Werror and -Wshadow on all your platforms
it can be tricky deploying production source using -Werror because different platforms and compilers and libraries can emit different warnings. You probably don't want to kill a user's entire build just because their version of GCC on a platform you've never seen complains in new and wonderous ways.
extra fancy options include -Wstrict-overflow -fno-strict-aliasing
Either specify -fno-strict-aliasing or be sure to only access objects as the type they have at creation. Since so much existing C code aliases across types, using -fno-strict-aliasing is a much safer bet if you don't control the entire underlying source tree.
as of now, Clang reports some valid syntax as a warning, so you should add -Wno-missing-field-initializers
GCC fixed this unnecessary warning after GCC 4.7.0
Building&lt;/p&gt;
&lt;p&gt;Compilation units
The most common way of building C projects is to decompose every source file into an object file then link all the objects together at the end. This procedure works great for incremental development, but it is suboptimal for performance and optimization. Your compiler can't detect potential optimization across file boundaries this way.
LTO — Link Time Optimization
LTO fixes the "source analysis and optimization across compilation units problem" by annotating object files with intermediate representation so source-aware optimizations can be carried out across compilation units at link time (this slows down the linking process noticeably, but make -j helps).
clang LTO (guide)
gcc LTO
As of 2016, clang and gcc releases support LTO by just adding -flto to your command line options during object compilation and final library/program linking.
LTO still needs some babysitting though. Sometimes, if your program has code not used directly but used by additional libraries, LTO can evict functions or code because it detects, globally when linking, some code is unused/unreachable and doesn't need to be included in the final linked result.
Arch&lt;/p&gt;
&lt;p&gt;-march=native
give the compiler permission to use your CPU's full feature set
again, performance testing and regression testing is important (then comparing the results across multiple compilers and/or compiler versions) is important to make sure any enabled optimizations don't have adverse side effects.
-msse2 and -msse4.2 may be useful if you need to target not-your-build-machine features.
Writing code
Types
If you find yourself typing char or int or short or long or unsigned into new code, you're doing it wrong.&lt;/p&gt;
&lt;p&gt;For modern programs, you should #include &lt;stdint.h&gt; then use standard types.&lt;/p&gt;
&lt;p&gt;The common standard types are:&lt;/p&gt;
&lt;p&gt;int8_t, int16_t, int32_t, int64_t — signed integers
uint8_t, uint16_t, uint32_t, uint64_t — unsigned integers
float — standard 32-bit floating point
double - standard 64-bit floating point
Notice we don't have char anymore. char is actually misnamed and misused in C.&lt;/p&gt;
&lt;p&gt;Developers routinely abuse char to mean "byte" even when they are doing unsigned byte manipulations. It's much cleaner to use uint8_t to mean single a unsigned-byte/octet-value and uint8_t * to mean sequence-of-unsigned-byte/octet-values.&lt;/p&gt;
&lt;p&gt;One Exception to never-char&lt;/p&gt;
&lt;p&gt;The only acceptable use of char in 2016 is if a pre-existing API requires char (e.g. strncat, printf'ing "%s", ...) or if you're initializing a read-only string (e.g. const char *hello = "hello";) because the C type of string literals ("hello") is char [].&lt;/p&gt;
&lt;p&gt;ALSO: In C11 we have native unicode support, and the type of UTF-8 string literals is still char * even for multibyte sequences like const char *abcgrr = u8"abc??";.&lt;/p&gt;
&lt;p&gt;Signedness&lt;/p&gt;
&lt;p&gt;At no point should you be typing the word unsigned into your code. We can now write code without the ugly C convention of multi-word types that impair readability as well as usage. Who wants to type unsigned long long int when you can type uint64_t? The &lt;stdint.h&gt; types are more explicit, more exact in meaning, convey intentions better, and are more compact for typographic usage and readability.&lt;/p&gt;
&lt;p&gt;But, you may say, "I need to cast pointers to long for dirty pointer math!"&lt;/p&gt;
&lt;p&gt;You may say that. But you are wrong.&lt;/p&gt;
&lt;p&gt;The correct type for pointer math is uintptr_t defined in &lt;stdint.h&gt;, while the also useful ptrdiff_t is defined in stddef.h.&lt;/p&gt;
&lt;p&gt;Instead of:&lt;/p&gt;
&lt;p&gt;long diff = (long)ptrOld - (long)ptrNew;
Use:&lt;/p&gt;
&lt;p&gt;ptrdiff_t diff = (uintptr_t)ptrOld - (uintptr_t)ptrNew;
Also:&lt;/p&gt;
&lt;p&gt;printf("%p is unaligned by %" PRIuPTR " bytes.\n", (void &lt;em&gt;)p, ((uintptr_t)somePtr &amp;amp; (sizeof(void &lt;/em&gt;) - 1)));
System-Dependent Types&lt;/p&gt;
&lt;p&gt;You continue arguing, "on a 32 bit platform I want 32 bit longs and on a 64 bit platform I want 64 bit longs!"&lt;/p&gt;
&lt;p&gt;If we skip over the line of thinking where you are deliberately introducing difficult to reason about code by using two different sizes depending on platform, you still don't want to use long for system-dependent types.&lt;/p&gt;
&lt;p&gt;In these situations, you should use intptr_t — the integer type defined to be the word size of your current platform.&lt;/p&gt;
&lt;p&gt;On 32-bit platforms, intptr_t is int32_t.&lt;/p&gt;
&lt;p&gt;On 64-bit platforms, intptr_t is int64_t.&lt;/p&gt;
&lt;p&gt;intptr_t also comes in a uintptr_t flavor.&lt;/p&gt;
&lt;p&gt;For holding pointer offsets, we have the aptly named ptrdiff_t which is the proper type for storing values of subtracted pointers.&lt;/p&gt;
&lt;p&gt;Maximum Value Holders&lt;/p&gt;
&lt;p&gt;Do you need an integer type capable of holding any integer usable on your system?&lt;/p&gt;
&lt;p&gt;People tend to use the largest known type in this case, such as casting smaller unsigned types to uint64_t, but there's a more technically correct way to guarantee any value can hold any other value.&lt;/p&gt;
&lt;p&gt;The safest container for any integer is intmax_t (also uintmax_t). You can assign or cast any signed integer to intmax_t with no loss of precision, and you can assign or cast any unsigned integer to uintmax_t with no loss of precision.&lt;/p&gt;
&lt;p&gt;That Other Type&lt;/p&gt;
&lt;p&gt;The most widely used system-dependent type is size_t.&lt;/p&gt;
&lt;p&gt;size_t is defined as "an integer capable of holding the largest array index" which also means it's capable of holding the largest memory offset in your program.&lt;/p&gt;
&lt;p&gt;In practical use, size_t is the return type of sizeof operator.&lt;/p&gt;
&lt;p&gt;In either case: size_t is practically defined to be the same as uintptr_t on all modern platforms, so on a 32-bit platform size_t is uint32_t and on a 64-bit platform size_t is uint64_t.&lt;/p&gt;
&lt;p&gt;There is also ssize_t which is a signed size_t used as the return value from library functions that return -1 on error. (Note: ssize_t is POSIX so does not apply to Windows interfaces.)&lt;/p&gt;
&lt;p&gt;So, should you use size_t for arbitrary system-dependent sizes in your own function parameters? Technically, size_t is the return type of sizeof, so any functions accepting a size value representing a number of bytes is allowed to be a size_t.&lt;/p&gt;
&lt;p&gt;Other uses include: size_t is the type of the argument to malloc, and ssize_t is the return type of read() and write() (except on Windows where ssize_t doesn't exist and the return values are just int).&lt;/p&gt;
&lt;p&gt;Printing Types&lt;/p&gt;
&lt;p&gt;You should never cast types during printing. You should use proper type specifiers.&lt;/p&gt;
&lt;p&gt;These include, but are not limited to:&lt;/p&gt;
&lt;p&gt;size_t - %zu
ssize_t - %zd
ptrdiff_t - %td
raw pointer value - %p (prints hex in modern compilers; cast your pointer to (void &lt;em&gt;) first)
64-bit types should be printed using PRIu64 (unsigned) and PRId64 (signed)
on some platforms a 64-bit value is a long and on others it's a long long
it is actually impossible to specify a correct cross-platform format string without these format macros because the types change out from under you (and remember, casting values before printing is not safe or logical).
intptr_t — "%" PRIdPTR
uintptr_t — "%" PRIuPTR
intmax_t — "%" PRIdMAX
uintmax_t — "%" PRIuMAX
One note about the PRI&lt;/em&gt; formatting specifiers: they are macros and the macros expand to proper printf type specifiers on a platform-specific basis. This means you can't do:&lt;/p&gt;
&lt;p&gt;printf("Local number: %PRIdPTR\n\n", someIntPtr);
but instead, because they are macros, you do:&lt;/p&gt;
&lt;p&gt;printf("Local number: %" PRIdPTR "\n\n", someIntPtr);
Notice you put the % inside your format string literal, but the type specifier is outside your format string literal because all adjacent strings get concatentated by the preprocessor into one final combined string literal.&lt;/p&gt;
&lt;p&gt;C99 allows variable declarations anywhere
So, do NOT do this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;do THIS instead:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Caveat: if you have tight loops, test the placement of your initializers. Sometimes scattered declarations can cause unexpected slowdowns. For regular non-fast-path code (which is most of everything in the world), it's best to be as clear as possible, and defining types next to your initializations is a big readability improvement.&lt;/p&gt;
&lt;p&gt;C99 allows for loops to declare counters inline
So, do NOT do this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Do THIS instead:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;One exception: if you need to retain your counter value after the loop exits, obviously don't declare your counter scoped to the loop itself.&lt;/p&gt;
&lt;p&gt;Modern compilers support #pragma once
So, do NOT do this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#ifndef PROJECT_HEADERNAME&lt;/span&gt;
&lt;span class="cp"&gt;#define PROJECT_HEADERNAME&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="cp"&gt;#endif &lt;/span&gt;&lt;span class="cm"&gt;/* PROJECT_HEADERNAME */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Do THIS instead:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#pragma once&lt;/span&gt;
&lt;span class="c"&gt;#pragma once tells the compiler to only include your header once and you do not need three lines of header guards anymore. This pragma is widely supported across all compilers across all platforms and is recommended over manually naming header guards.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;For more details, see list of supported compilers at pragma once.&lt;/p&gt;
&lt;p&gt;C allows static initialization of auto-allocated arrays
So, do NOT do this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;memset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Do THIS instead:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;C allows static initialization of auto-allocated structs
So, do NOT do this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;thing&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;uint64_t&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;thing&lt;/span&gt; &lt;span class="n"&gt;localThing&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;initThing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;memset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;localThing&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;localThing&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Do THIS instead:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;thing&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;uint64_t&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;thing&lt;/span&gt; &lt;span class="n"&gt;localThing&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;IMPORTANT NOTE: If your struct has padding, the {0} method does not zero out extra padding bytes. For example, struct thing has 4 bytes of padding after counter (on a 64-bit platform) because structs are padded to word-sized increments. If you need to zero out an entire struct including unused padding, use memset(&amp;amp;localThing, 0, sizeof(localThing)) because sizeof(localThing) == 16 bytes even though the addressable contents is only 8 + 4 = 12 bytes.&lt;/p&gt;
&lt;p&gt;If you need to re-initialize already allocated structs, declare a global zero-struct for later assignment:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;thing&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;uint64_t&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;thing&lt;/span&gt; &lt;span class="n"&gt;localThingNull&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;thing&lt;/span&gt; &lt;span class="n"&gt;localThing&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{.&lt;/span&gt;&lt;span class="n"&gt;counter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;localThing&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;localThingNull&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If you are lucky enough to be in a C99 (or newer) environment, you can use compound literals instead of keeping a global "zero struct" around (also see, from 2001, The New C: Compound Literals).&lt;/p&gt;
&lt;p&gt;Compound literals allow you to directly assign from anyonomus structs:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;localThing&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;thing&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;C99 added variable length arrays (C11 made them optional)
So, do NOT do this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;uintmax_t&lt;/span&gt; &lt;span class="n"&gt;arrayLength&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;strtoumax&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[];&lt;/span&gt;

&lt;span class="n"&gt;array&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;arrayLength&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="cm"&gt;/* remember to free(array) when you&amp;#39;re done using it */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Do THIS instead:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;uintmax_t&lt;/span&gt; &lt;span class="n"&gt;arrayLength&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;strtoumax&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;arrayLength&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="cm"&gt;/* no need to free array */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;IMPORTANT CAVEAT: variable length arrays are (usually) stack allocated just like regular arrays. If you wouldn't create a 3 million element regular array statically, don't attempt to create a 3 million element array at runtime using this syntax. These are not scalable python/ruby auto-growing lists. If you specify a runtime array length and the length is too big for your stack, your program will do awful things (crashes, security issues). Variable Length Arrays are convienient for small, single-purpose situations, but should not be relied on at scale in production software. If sometimes you need a 3 element array and other times a 3 million element array, definitely do not use the variable length array capability.&lt;/p&gt;
&lt;p&gt;It's good to be aware of the VLA syntax in case you encounter it live (or want it for quick one-off testing), but it can almost be considered a dangerous anti-pattern since you can crash your programs fairly simple by forgetting element size bounds checks or by forgetting you are on a strange target platform with no free stack space.&lt;/p&gt;
&lt;p&gt;NOTE: You must be certain arrayLength is a reasonable size in this situation. (i.e. less than a few KB, sometime your stack will max out at 4 KB on weird platforms). You can't stack allocate huge arrays (millions of entries), but if you know you have a limited count, it's much easier to use C99 VLA capabilities rather than manually requesting heap memory from malloc.&lt;/p&gt;
&lt;p&gt;DOUBLE NOTE: there is no user input checking above, so the user can easily kill your program by allocating a giant VLA. Some people go as far to call VLAs an anti-pattern, but if you keep your bounds tight, it can be a tiny win in certain situations.&lt;/p&gt;
&lt;p&gt;C99 allows annotating non-overlapping pointer parameters
See the restrict keyword (often __restrict)&lt;/p&gt;
&lt;p&gt;Parameter Types
If a function accepts arbitrary input data and a length to process, don't restrict the type of the parameter.&lt;/p&gt;
&lt;p&gt;So, do NOT do this:&lt;/p&gt;
&lt;p&gt;void processAddBytesOverflow(uint8_t *bytes, uint32_t len) {
    for (uint32_t i = 0; i &amp;lt; len; i++) {
        bytes[0] += bytes[i];
    }
}
Do THIS instead:&lt;/p&gt;
&lt;p&gt;void processAddBytesOverflow(void &lt;em&gt;input, uint32_t len) {
    uint8_t &lt;/em&gt;bytes = input;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;bytes&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;bytes&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}
The input types to your functions describe the interface to your code, not what your code is doing with the parameters. The interface to the code above means "accept a byte array and a length", so you don't want to restrict your callers to only uint8_t byte streams. Maybe your users even want to pass in old-style char * values or something else unexpected.&lt;/p&gt;
&lt;p&gt;By declaring your input type as void * then re-assigning or re-casting to the actual type you want inside your function, you save the users of your function from having to think about abstractions inside your own library.&lt;/p&gt;
&lt;p&gt;Some readers have pointed out alignment problems with this example, but we are accessing single byte elements of the input, so everything is fine. If instead we were casting the input to wider types, we would need to watch out for alignment issues. For a different write up dealing with cross-platform alignment issues, see Unaligned Memory Access. (reminder: this page of generic overview details isn't about cross-architecture intricacies of C, so external knowledge and experience is expected to fully use any examples provided.)&lt;/p&gt;
&lt;p&gt;Return Parameter Types
C99 gives us the power of &lt;stdbool.h&gt; which defines true to 1 and false to 0.&lt;/p&gt;
&lt;p&gt;For success/failure return values, functions should return true or false, not an int32_t return type with manually specifying 1 and 0 (or worse, 1 and -1 (or is it 0 success and 1 failure? or is it 0 success and -1 failure?)).&lt;/p&gt;
&lt;p&gt;If a function mutates an input parameter to the extent the parameter is invalidated, instead of returning the altered pointer, your entire API should force double pointers as parameters anywhere an input can be invalidated. Coding with "for some calls, the return value invalidates the input" is too error prone for mass usage.&lt;/p&gt;
&lt;p&gt;So, do NOT do this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;growthOptional&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;grow&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;currentLen&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;newLen&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;newLen&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;currentLen&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;newGrow&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;realloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;grow&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;newLen&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;newGrow&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="cm"&gt;/* resize success */&lt;/span&gt;
            &lt;span class="n"&gt;grow&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newGrow&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="cm"&gt;/* resize failed, free existing and signal failure through NULL */&lt;/span&gt;
            &lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;grow&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;grow&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;grow&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Do THIS instead:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* Return value:&lt;/span&gt;
&lt;span class="cm"&gt; *  - &amp;#39;true&amp;#39; if newLen &amp;gt; currentLen and attempted to grow&lt;/span&gt;
&lt;span class="cm"&gt; *    - &amp;#39;true&amp;#39; does not signify success here, the success is still in &amp;#39;*_grow&amp;#39;&lt;/span&gt;
&lt;span class="cm"&gt; *  - &amp;#39;false&amp;#39; if newLen &amp;lt;= currentLen */&lt;/span&gt;
&lt;span class="n"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;growthOptional&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;_grow&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;currentLen&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;newLen&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;grow&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;_grow&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;newLen&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;currentLen&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;newGrow&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;realloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;grow&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;newLen&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;newGrow&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="cm"&gt;/* resize success */&lt;/span&gt;
            &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;_grow&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newGrow&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="cm"&gt;/* resize failure */&lt;/span&gt;
        &lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;grow&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;_grow&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="cm"&gt;/* for this function,&lt;/span&gt;
&lt;span class="cm"&gt;         * &amp;#39;true&amp;#39; doesn&amp;#39;t mean success, it means &amp;#39;attempted grow&amp;#39; */&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Or, even better, Do THIS instead:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;growthResult&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;GROWTH_RESULT_SUCCESS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;GROWTH_RESULT_FAILURE_GROW_NOT_NECESSARY&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;GROWTH_RESULT_FAILURE_ALLOCATION_FAILED&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;growthResult&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;growthResult&lt;/span&gt; &lt;span class="nf"&gt;growthOptional&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;_grow&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;currentLen&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;newLen&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;grow&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;_grow&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;newLen&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;currentLen&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;newGrow&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;realloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;grow&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;newLen&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;newGrow&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="cm"&gt;/* resize success */&lt;/span&gt;
            &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;_grow&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newGrow&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;GROWTH_RESULT_SUCCESS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="cm"&gt;/* resize failure, don&amp;#39;t remove data because we can signal error */&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;GROWTH_RESULT_FAILURE_ALLOCATION_FAILED&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;GROWTH_RESULT_FAILURE_GROW_NOT_NECESSARY&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Formatting
Coding style is simultaneously very important and utterly worthless.&lt;/p&gt;
&lt;p&gt;If your project has a 50 page coding style guideline, nobody will help you. But, if your code isn't readable, nobody will want to help you.&lt;/p&gt;
&lt;p&gt;The solution here is to always use an automated code formatter.&lt;/p&gt;
&lt;p&gt;The only usable C formatter as of 2016 is clang-format. clang-format has the best defaults of any automatic C formatter and is still actively developed.&lt;/p&gt;
&lt;p&gt;Here's my preferred script to run clang-format with good parameters:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#!/usr/bin/env bash&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;clang-format -style="{BasedOnStyle: llvm, IndentWidth: 4, AllowShortFunctionsOnASingleLine: None, KeepEmptyLinesAtTheStartOfBlocks: false}" "$@"
Then call it as (assuming you named the script cleanup-format):&lt;/p&gt;
&lt;p&gt;matt@foo:~/repos/badcode% cleanup-format -i *.{c,h,cc,cpp,hpp,cxx}
The -i option overwrites existing files in place with formatting changes instead of writing to new files or creating backup files.&lt;/p&gt;
&lt;p&gt;If you have many files, you can recursively process an entire source tree in parallel:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#!/usr/bin/env bash&lt;/span&gt;

&lt;span class="c"&gt;# note: clang-tidy only accepts one file at a time, but we can run it&lt;/span&gt;
&lt;span class="c"&gt;#       parallel against disjoint collections at once.&lt;/span&gt;
find . &lt;span class="se"&gt;\(&lt;/span&gt; -name &lt;span class="se"&gt;\*&lt;/span&gt;.c -or -name &lt;span class="se"&gt;\*&lt;/span&gt;.cpp -or -name &lt;span class="se"&gt;\*&lt;/span&gt;.cc &lt;span class="se"&gt;\)&lt;/span&gt; |xargs -n1 -P4 cleanup-tidy

&lt;span class="c"&gt;# clang-format accepts multiple files during one run, but let&amp;#39;s limit it to 12&lt;/span&gt;
&lt;span class="c"&gt;# here so we (hopefully) avoid excessive memory usage.&lt;/span&gt;
find . &lt;span class="se"&gt;\(&lt;/span&gt; -name &lt;span class="se"&gt;\*&lt;/span&gt;.c -or -name &lt;span class="se"&gt;\*&lt;/span&gt;.cpp -or -name &lt;span class="se"&gt;\*&lt;/span&gt;.cc -or -name &lt;span class="se"&gt;\*&lt;/span&gt;.h &lt;span class="se"&gt;\)&lt;/span&gt; |xargs -n12 -P4 cleanup-format -i
Now, there&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;s a new cleanup-tidy script there. The contents of cleanup-tidy is:

&lt;span class="c"&gt;#!/usr/bin/env bash&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;clang-tidy \
    -fix \
    -fix-errors \
    -header-filter=.* \
    --checks=readability-braces-around-statements,misc-macro-parentheses \
    $1 \
    -- -I.
clang-tidy is policy driven code refactoring tool. The options above enable two fixups:&lt;/p&gt;
&lt;p&gt;readability-braces-around-statements — force all if/while/for statement bodies to be enclosed in braces
It's an accident of history for C to have "brace optional" single statements after loop constructs and conditionals. It is inexcusable to write modern code without braces enforced on every loop and every conditional. Trying to argue "but, the compiler accepts it!" has nothing to do with the readability, maintainability, understandability, or skimability of code. You aren't programming to please your compiler, you are programming to please future people who have to maintain your current brain state years after everybody has forgotten why anything exists in the first place.
misc-macro-parentheses — automatically add parens around all parameters used in macro bodies
clang-tidy is great when it works, but for some complex code bases it can get stuck. Also, clang-tidy doesn't format, so you need to run clang-format after you tidy to align new braces and reflow macros.&lt;/p&gt;
&lt;p&gt;Readability
the writing seems to start slowing down here...&lt;/p&gt;
&lt;p&gt;Comments&lt;/p&gt;
&lt;p&gt;logical self-contained portions of code file&lt;/p&gt;
&lt;p&gt;File Structure&lt;/p&gt;
&lt;p&gt;Try to limit files to a max of 1,000 lines (1,500 lines in really bad cases). If your tests are in-line with your source file (for testing static functions, etc), adjust as necessary.&lt;/p&gt;
&lt;p&gt;misc thoughts
Never use malloc&lt;/p&gt;
&lt;p&gt;You should always use calloc. There is no performance penalty for getting zero'd memory. If you don't like the function protype of calloc(object count, size per object) you can wrap it with #define mycalloc(N) calloc(1, N).&lt;/p&gt;
&lt;p&gt;Readers have commented on a few things here:&lt;/p&gt;
&lt;p&gt;calloc does have a performance impact for huge allocations
calloc does have a performance impact on weird platforms (minimal embedded systems, game consoles, 30 year old hardware, ...)
wrapping calloc(element count, size of each element) is not always a good idea.
a good reason to avoid malloc() is it can't check for integer overflow and is a potential security risk
calloc allocations remove valgrind's ability to warn you about unintentional reads or copies of uninitialized memory since allocations get initialized to 0 automatically
Those are good points, and that's why we always must do performance testing and regression testing for speed across compilers, platforms, operating systems, and hardware devices.&lt;/p&gt;
&lt;p&gt;One advantage of using calloc() directly without a wrapper is, unlike malloc(), calloc() can check for integer overflow because it multiplies its arguments together to obtain your final allocation size. If you are only allocating tiny things, wrapping calloc() is fine. If you are allocating potentially unbounded streams of data, you may want to retain the regular calloc(element count, size of each element) calling convention.&lt;/p&gt;
&lt;p&gt;No advice can be universal, but trying to give exactly perfect generic recommendations would end up reading like a book of language specifications.&lt;/p&gt;
&lt;p&gt;For references on how calloc() gives you clean memory for free, see these nice writeups:&lt;/p&gt;
&lt;p&gt;Benchmarking fun with calloc() and zero pages (2007)
Copy-on-write in virtual memory management
I still stand by my recommendation of always using calloc() for most common scenarios of 2016 (assumption: x64 target platforms, human-sized data, not including human genome-sized data). Any deviations from "expected" drag us into the pit of despair of "domain knowledge," which are words we shan't speak this day.&lt;/p&gt;
&lt;p&gt;Subnote: The pre-zero'd memory delivered to you by calloc() is a one-shot deal. If you realloc() your calloc() allocation, the grown memory extended by realloc is not new zero'd out memory. Your grown allocation is filled with whatever regular uninitialized contents your kernel provides. If you need zero'd memory after a realloc, you must manually memset() the extent of your grown allocation.&lt;/p&gt;
&lt;p&gt;Never memset (if you can avoid it)&lt;/p&gt;
&lt;p&gt;Never memset(ptr, 0, len) when you can statically initialize a structure (or array) to zero (or reset it back to zero by assigning from an in-line compound literal or by assigning from a global zero'd out structure).&lt;/p&gt;
&lt;p&gt;Though, memset() is your only choice if you need to zero out a struct including its padding bytes (because {0} only sets defined fields, not undefined offsets filled by padding).&lt;/p&gt;
&lt;p&gt;Learn More
Also see Fixed width integer types (since C99)&lt;/p&gt;
&lt;p&gt;Also see Apple's Making Code 64-Bit Clean&lt;/p&gt;
&lt;p&gt;Also see the sizes of C types across architectures — unless you keep that entire table in your head for every line of code you write, you should use explicitly defined integer widths and never use char/short/int/long built-in storage types.&lt;/p&gt;
&lt;p&gt;Also see size_t and ptrdiff_t&lt;/p&gt;
&lt;p&gt;Also see Secure Coding. If you really want to write everything perfectly, simply memorize their thousand simple examples.&lt;/p&gt;
&lt;p&gt;Also see Modern C by Jens Gustedt at Inria.&lt;/p&gt;
&lt;p&gt;Closing
Writing correct code at scale is essentially impossible. We have multiple operating systems, runtimes, libraries, and hardware platforms to worry about without even considering things like random bit flips in RAM or our block devices lying to us with unknown probability.&lt;/p&gt;
&lt;p&gt;The best we can do is write simple, understandable code with as few indirections and as little undocumented magic as possible.&lt;/p&gt;
&lt;p&gt;-Matt — @mattsta — ?mattsta&lt;/p&gt;
&lt;p&gt;Attributions
This made the twitter and HN rounds, so many people helpfully pointed out flaws or biased thoughts I'm promulgating here.&lt;/p&gt;
&lt;p&gt;First up, Jeremy Faller and Sos Sosowski and Martin Heistermann and a few other people were kind enough to point out my memset() example was broken and provided the proper fix.&lt;/p&gt;
&lt;p&gt;Martin Heistermann also pointed out the localThing = localThingNull example was broken.&lt;/p&gt;
&lt;p&gt;The opening quote about not writing C if you can avoid it is from the wise internet sage @badboy_.&lt;/p&gt;
&lt;p&gt;Remi Gacogne pointed out I forgot -Wextra.&lt;/p&gt;
&lt;p&gt;Levi Pearson pointed out gcc-5 defaults to gnu11 instead of c89 as well as clarifying the default clang mode.&lt;/p&gt;
&lt;p&gt;Christopher pointed out the -O2 vs -O3 section could use a little more clarification.&lt;/p&gt;
&lt;p&gt;Chad Miller pointed out I was being lazy in the clang-format script params.&lt;/p&gt;
&lt;p&gt;Many people also pointed out the calloc() advice isn't always a good idea if you have extreme circumstances or non-standard hardware (examples of bad ideas: huge allocations, allocations on embedded jiggers, allocations on 30 year old hardware, etc).&lt;/p&gt;
&lt;p&gt;Charles Randolph pointed out I misspelled the world "Building."&lt;/p&gt;
&lt;p&gt;Sven Neuhaus pointed out kindly I also do not posess the ability to spell "initialization" or "initializers." (and also pointed out I misspelled "initialization" wrong the first time here as well)&lt;/p&gt;
&lt;p&gt;Colm MacCárthaigh pointed out I forgot to mention #pragma once.&lt;/p&gt;
&lt;p&gt;Jeffrey Yasskin pointed out we should kill strict aliasing too (mainly a gcc optimization).&lt;/p&gt;
&lt;p&gt;Jeffery Yasskin also provided better wording around the -fno-strict-aliasing section.&lt;/p&gt;
&lt;p&gt;Chris Palmer and a few others pointed out calloc-vs-malloc parameter advantages and the overall drawback of writing a wrapper for calloc() because calloc() provides a more secure interface than malloc() in the first place.&lt;/p&gt;
&lt;p&gt;Damien Sorresso pointed out we should remind people realloc() doesn't zero out grown memory after an initial zero'd calloc() request.&lt;/p&gt;
&lt;p&gt;Pat Pogson pointed out I was unable to spell the word "declare" correctly as well.&lt;/p&gt;
&lt;p&gt;@TopShibe pointed out the stack-allocated initialization example was wrong because the examples I gave were global variables. Updated wording to just mean "auto-allocated" things, be it stack or data sections.&lt;/p&gt;
&lt;p&gt;Jonathan Grynspan suggested harsher wording around the VLA example because they are dangerous when used incorrectly.&lt;/p&gt;
&lt;p&gt;David O'Mahony kindly pointed out I can't spell "specify" either.&lt;/p&gt;
&lt;p&gt;Dr. David Alan Gilbert pointed out ssize_t is a POSIXism and Windows either doesn't have it or defines ssize_t as an unsigned quantity which obviously introduces all kinds of fun behavior when your type is signed on POSIX platforms and unsigned on Windows.&lt;/p&gt;
&lt;p&gt;Chris Ridd suggested we explicitly mention C99 is C from 1999 and C11 is C from 2011 because otherwise it looks strange having 11 be newer than 99.&lt;/p&gt;
&lt;p&gt;Chris Ridd also noticed the clang-format example used unclear naming conventions and suggested better consistency across examples.&lt;/p&gt;
&lt;p&gt;Anthony Le Goff pointed us to a book-length treatment of many modern C ideas called Modern C.&lt;/p&gt;
&lt;p&gt;Stuart Popejoy pointed out my inaccurate spelling of deliberately was truly inaccurate.&lt;/p&gt;
&lt;p&gt;jack rosen pointed out my usage of the word 'exists' does not mean 'exits' as I intended.&lt;/p&gt;
&lt;p&gt;Jo Booth pointed out I like to spell compatibility as compatability, which seems more logical, but English commonality disagrees.&lt;/p&gt;
&lt;p&gt;Stephen Anderson decoded my aberrant spelling of 'stil' back into 'still.'&lt;/p&gt;
&lt;p&gt;Richard Weinberger pointed out struct initialization with {0} doesn't zero out padding bytes, so sending a {0} struct over the wire can leak unintended bytes on under-specified structs.&lt;/p&gt;
&lt;p&gt;@JayBhukhanwala pointed out the function comment in Return Parameter Types was inaccurate because I didn't update the comment when the code changed (story of our lives, right?).&lt;/p&gt;
&lt;p&gt;Lorenzo pointed out we should explicitly provide a warning concerning potential cross-platform alignment issues in section Parameter Types.&lt;/p&gt;
&lt;p&gt;Paolo G. Giarrusso re-clarified the alignment warning I previously added to be more correct regarding the examples given.&lt;/p&gt;
&lt;p&gt;Fabian Kl?tzl provided the valid struct compound literal assignment example since it's perfectly valid syntax I just hadn't run across before.&lt;/p&gt;
&lt;p&gt;Omkar Ekbote provided a very thorough walkthrough of typos and consistency problems here including that I couldn't spell "platform," "actually," "defining," "experience," "simultaneously," "readability," as well as noted some other unclear wordings.&lt;/p&gt;
&lt;p&gt;Carlo Bellettini fixed my aberrant spelling of the word aberrant.&lt;/p&gt;
&lt;p&gt;Keith S Thompson provided many technical corrections in his great article how-to-c-response.&lt;/p&gt;
&lt;p&gt;Many people on reddit went apeshit because this article originally had #import somewhere by mistake. Sorry, crazy people, but this started out as an unedited and unreviewed year old draft when originally pushed live. The error has since been remedied.&lt;/p&gt;
&lt;p&gt;Some people also pointed out the static initialization example uses globals which are always initialized to zero by default anyway (and that they aren't even initialized, they are statically allocated). This is a poor choice of example on my part, but the concepts still stand for typical usage within function scopes. The examples were meant to be any generic "code snippet" and not necessarily top level globals.&lt;/p&gt;
&lt;p&gt;A few people seem to have read this as an "I hate C" page, but it isn't. C is dangerous in the wrong hands (not enough testing, not enough experience when widely deployed), so paradoxically the two kinds of C developers should only be novice hobbyists (code failure causes no problems, it's just a toy) or people who are willing to test their asses off (code failure causes life or financial loss, it's not just a toy) should be writting C code for production usage. There's not much room for "casual observer C development." For the rest of the world, that's why we have Erlang.&lt;/p&gt;
&lt;p&gt;Many people have also mentioned their own pet issues as well or issues beyond the scope of this article (including new C11 only features like George Makrydakis reminding us about C11 generic abilities).&lt;/p&gt;
&lt;p&gt;Perhaps another article about "Practical C" will show up to cover testing, profiling, performance tracing, optional-but-useful warning levels, etc.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">muou</dc:creator><pubDate>Mon, 11 Jan 2016 23:00:00 +0800</pubDate><guid>tag:muou55555.github.io,2016-01-11:content/articles/2016/01/11/howtoc/</guid><category>C</category></item><item><title>基于python开发TerminalTool</title><link>https://muou55555.github.io/content/articles/2016/01/11/TerminalTool/</link><description>&lt;h2&gt;项目概述&lt;/h2&gt;
&lt;p&gt;基于python语言开发，表格式终端命令菜单，会在此菜单上添加嵌入式开发中经常用到的工具类方法。目前按业务控制功能、视图、通用包进行分类。
目前此项目已开源，开源地址访问：&lt;br /&gt;
&lt;br&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;&lt;a href="https://github.com/muou55555/TerminalTool"&gt;https://github.com/muou55555/TerminalTool&lt;/a&gt;   &lt;/p&gt;
&lt;h3&gt;一、pytable&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;功能说明&lt;/code&gt;：表格类，支持按行增加内容；支持多列；支持缺省列时补空；运行是否显示表格标题&lt;/p&gt;
&lt;h4&gt;1.1 使用方法&lt;/h4&gt;
&lt;p&gt;1、初始化pytable&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Pytable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Table Title&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2、显示表标题&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_table_header&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3、添加行数据&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_row_data&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1 - Home&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;2 - Telnet&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;3 - SSH&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;4、显示表格&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;二、pymenu&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;功能说明&lt;/code&gt;：表格菜单类，支持按行增加内容；支持多列；支持缺省列时补空；支持多级子菜单；支持退出确认机制；支持自定义菜单功能实现&lt;/p&gt;
&lt;h4&gt;2.1 使用方法&lt;/h4&gt;
&lt;p&gt;1、初始化pymenu&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;main_menu&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Pymenu&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Main Menu&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;back_key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;q&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2、添加行数据&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;main_menu&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_field&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Telnet&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Telnet&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;main_menu&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_field&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;4&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;SSH&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fun_test&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;main_menu&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_field&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;b&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;sub b&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3、显示菜单&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;main_menu&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;DEMO界面&lt;/h3&gt;
&lt;p&gt;pymenu和pytable界面
&lt;img alt="TerminalToolExample.png" src="/images/Python/TerminalToolExample.png" /&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">muou</dc:creator><pubDate>Mon, 11 Jan 2016 15:32:00 +0800</pubDate><guid>tag:muou55555.github.io,2016-01-11:content/articles/2016/01/11/TerminalTool/</guid><category>Python</category></item><item><title>Learning links</title><link>https://muou55555.github.io/content/articles/2016/01/10/Study/</link><description>&lt;p&gt;&lt;a href="http://www.embeddedlog.com"&gt;http://www.embeddedlog.com&lt;/a&gt;&lt;br&gt;&lt;br&gt;
&lt;a href="http://kentwills.github.io"&gt;http://kentwills.github.io&lt;/a&gt;&lt;br&gt;&lt;br&gt;
&lt;a href="http://rjweiss.github.io"&gt;http://rjweiss.github.io&lt;/a&gt;&lt;br&gt;&lt;br&gt;
&lt;a href="https://github.com/DandyDev"&gt;https://github.com/DandyDev&lt;/a&gt;&lt;br&gt;&lt;br&gt;
&lt;a href="http://www.oschina.net"&gt;oschina&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">muou</dc:creator><pubDate>Sun, 10 Jan 2016 10:20:00 +0800</pubDate><guid>tag:muou55555.github.io,2016-01-10:content/articles/2016/01/10/Study/</guid><category>Study</category></item><item><title>冬天的故宫</title><link>https://muou55555.github.io/content/articles/2014/12/01/gugong/</link><description>&lt;p&gt;冬天的故宫，北京，2014年冬天
&lt;div&gt; 
&lt;img style="border-radius: 3%; display: block;" src="/images/gugong/1.jpg" alt="1"/&gt;
&lt;/div&gt; 
[我和我的侄女]&lt;/p&gt;
&lt;p&gt;&lt;br&gt;
&lt;div&gt; 
&lt;img style="border-radius: 3%; display: block;" src="/images/gugong/2.jpg" alt="2"/&gt;
&lt;/div&gt; 
[冬天的故宫，人很少]&lt;/p&gt;
&lt;p&gt;&lt;br&gt;
&lt;div&gt; 
&lt;img style="border-radius: 3%; display: block;" src="/images/gugong/3.jpg" alt="3"/&gt;
&lt;/div&gt;
[冬天的故宫，天很蓝]&lt;/p&gt;
&lt;p&gt;&lt;br&gt;
&lt;div&gt; 
&lt;img style="border-radius: 3%; display: block;" src="/images/gugong/4.jpg" alt="4"/&gt;
&lt;/div&gt;
[冬天的故宫，没有雾霾]&lt;/p&gt;
&lt;p&gt;&lt;br&gt;
&lt;div&gt; 
&lt;img style="border-radius: 3%; display: block;" src="/images/gugong/5.jpg" alt="5"/&gt;
&lt;/div&gt;
[冬天的故宫，很安静]&lt;/p&gt;
&lt;p&gt;&lt;br&gt;
&lt;div&gt; 
&lt;img style="border-radius: 3%; display: block;" src="/images/gugong/6.jpg" alt="6"/&gt;
&lt;/div&gt;
[冬天的故宫]&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">muou</dc:creator><pubDate>Mon, 01 Dec 2014 13:25:00 +0800</pubDate><guid>tag:muou55555.github.io,2014-12-01:content/articles/2014/12/01/gugong/</guid><category>Travel</category></item></channel></rss>