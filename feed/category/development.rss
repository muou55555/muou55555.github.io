<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>木 偶</title><link>https://muou55555.github.com/</link><description>Software development and architecture blog</description><atom:link href="https://muou55555.github.com/feed/category/development.rss" rel="self"></atom:link><lastBuildDate>Fri, 15 Jul 2016 10:00:00 +0800</lastBuildDate><item><title>浅析 Linux 中的时间编程和实现原理[转]</title><link>https://muou55555.github.com/content/articles/2016/07/15/linux%20timer/</link><description>&lt;h2&gt;引子&lt;/h2&gt;
&lt;p&gt;我们都生活在时间中，但却无法去思考它。什么是时间呢？似乎这是一个永远也不能被回答的问题。然而作为一个程序员，在工作中，总有那么几次我必须思考什么是时间。比如，需要知道一段代码运行了多久；要在 log 文件中记录事件发生时的时间戳；再比如需要一个定时器以便能够定期做某些计算机操作。我发现，在计算机世界中，时间在不同场合也往往有不同的含义，让试图思考它的人感到迷茫。但值得庆幸的是，Linux 中的时间终究是可以理解的。因此我打算讨论一下有关时间的话题，尝试着深入理解 Linux 系统中 C 语言编程中的时间问题。主要内容如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第 1 部分是应用程序中的时间问题。有三个方面：程序计时需要；获取当前时间；定时器。&lt;/li&gt;
&lt;li&gt;第 2 部分包括时间硬件简介和 GlibC 实现时间函数的原理。&lt;/li&gt;
&lt;li&gt;第 3 和第 4 部分是 Linux 内核对时间的支持和实现原理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在开始第 1 部分，探讨应用开发中的时间编程问题。在这一部分中，所有的例子代码都在 GlibC 2.14，内核 2.6.33 的 Linux 系统下编译并验证执行过。读者如果使用低版本的 GlibC 和 Linux 内核有可能无法正确执行。&lt;/p&gt;
&lt;/div&gt;

&lt;h2&gt;获取当前时间&lt;/h2&gt;
&lt;h3&gt;时间的获取&lt;/h3&gt;
&lt;p&gt;在程序当中, 我们经常要输出系统当前的时间，比如日志文件中的每一个事件都要记录其产生时间。在 C 语言中获取当前时间的方法有以下几种，它们所获得的时间精度从秒级到纳秒，各有所不同。&lt;/p&gt;
&lt;h5&gt;表 1. C 时间函数&lt;/h5&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;function 定义&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;含义&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;返回值&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;精度&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;time()&lt;/td&gt;
&lt;td&gt;time 函数获得从 1970 年 1 月 1 日 0 点到当前的秒数，存储在_time_t_结构之中。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;time_t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;秒&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;gettimeofday()&lt;/td&gt;
&lt;td&gt;gettimeofday 函数返回从 1970 年 1 月 1 日 0 点以来，到现在的时间。用 timeval 数据结构表示。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;struct timeval&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;{&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;time_t tv_sec;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;long int tv_usec;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;};&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;微秒&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;clock_gettime()&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;clock_gettime 函数返回从 1970 年 1 月 1 日 0 点以来，到现在的时间。用 timespec 数据结构表示。&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;支持不广泛。属于实时扩展。&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;struct timespec&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;{&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;time_t tv_sec;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;long int tv_nsec;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;};&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;纳秒&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ftime()&lt;/td&gt;
&lt;td&gt;函数返回从 1970 年 1 月 1 日 0 点以来，到现在的时间。用&lt;code&gt;timeb&lt;/code&gt;数据结构表示。&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;已经过时, 被 time() 替代。尽量不使用。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;struct timeb {&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;time_t time;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;unsigned short&lt;/code&gt; `&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;`millitm;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;short timezone;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;short dstflag;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;`};```&lt;/td&gt;
&lt;td&gt;毫秒&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;GUN/Linux 提供了三个标准的 API 用来获取当前时间，time()/gettimeofday()/clock_gettime()，它们的区别仅在于获取的时间精度不同，您可以根据需要选取合适的调用。ftime() 是老的一些系统中的时间调用，很多 Linux 版本虽然支持它，但仅仅是为了向前兼容性，新开发的软件不建议使用 ftime() 来获得当前时间。&lt;/p&gt;
&lt;h3&gt;时间显示和转换&lt;/h3&gt;
&lt;p&gt;目前我们得到的时间是一个数字，无论精度如何，它代表的仅是一个差值。比如精度为秒的 time() 函数，返回一个 time_t 类型的整数。假设当前时间为 2011 年 12 月 7 日下午 20 点 29 分 51 秒，那么 time_t 的值为：1323318591。即距离 1970 年 1 月 1 日零点，我们已经过去了 1323318591 秒。（这里的 1970 年 1 月 1 日零点是格林威治时间，而不是北京时间。）我们下面讨论的时间如果不特别说明都是格林威治时间，也叫 GMT 时间，或者 UTC 时间。&lt;/p&gt;
&lt;p&gt;字符串“1323318591 秒”对于多数人都没有太大的意义，我们更愿意看到“2011 年 12 月 7 日”这样的显示。因此当我们得到秒，毫秒，甚至纳秒表示的当前时间之后，往往需要将这些数字转换为人们所熟悉的时间表示方法。&lt;/p&gt;
&lt;p&gt;由于国家，习惯和时区的不同，时间的表示方法并没有一个统一的格式。为了满足各种时间显示的需求，标准 C 库提供了许多时间格式转换的函数。这些函数的数量众多，容易让人迷惑，记住它们的用法十分不易。在这里我借用 Michael Kerrisk 在《Linux Programming Interface》一书中的插图，来对这些标准 C 函数进行一个总体的概览。&lt;/p&gt;
&lt;h5&gt;图 1. 各种时间显示格式转换函数关系图&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;固定格式转换&lt;/li&gt;
&lt;li&gt;用户指定格式转换函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;固定格式转换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用 ctime() 函数转换出来的时间格式是系统固定的，调用者无法改动，因此被称为固定格式转换。如果您对日期格式没有特殊的要求，那么用它基本上就可以了，简单，不用记忆很多的参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户指定格式转换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;典型的 ctime() 格式如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Wed Dec 7 20:45:43 PST 2011&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有些人觉得这个格式太长，类似 Wed，星期三这样的信息很多情况下都没有啥用途。人们可能更喜欢其他格式：比如&lt;strong&gt;2011-12-07 20:45&lt;/strong&gt;。在这种情况下，就需要进行时间显示格式转换。做法为：先把从内核得到的时间值转换为 struct tm 类型的值，然后调用 strftime() 等函数来输出自定义的时间格式字符串。&lt;/p&gt;
&lt;p&gt;下面我列举一些实例，以便读者更清晰地理解众多的时间转换函数的用法。&lt;/p&gt;
&lt;h3&gt;各标准 C 时间转换函数的解释和举例&lt;/h3&gt;
&lt;div class="codesection"&gt;

&lt;pre class="displaycode"&gt;char *ctime(const time_t *clock);&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;使用函数 ctime 将秒数转化为字符串. 这个函数的返回类型是固定的：一个可能值为”Thu Dec 7 14:58:59 2000”。这个字符串的长度和显示格式是固定的。&lt;/p&gt;
&lt;h5&gt;清单 1，time 的使用&lt;/h5&gt;
&lt;div class="codesection"&gt;

&lt;pre class="displaycode"&gt;#include &lt;time.h&gt;
int main ()
{
 time_t time_raw_format;
 time ( &amp;time_raw_format ); //获取当前时间
 printf (" time is [%d]\n", time_raw_format);
 //用 ctime 将时间转换为字符串输出
 printf ( "The current local time: %s", ctime(&amp;time_raw_format));
 return 0;
}&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;自定义格式转换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了更灵活的显示，需要把类型 time_t 转换为 tm 数据结构。tm 数据结构将时间分别保存到代表年，月，日，时，分，秒等不同的变量中。不再是一个令人费解的 64 位整数了。这种数据结构是各种自定义格式转换函数所需要的输入形式。&lt;/p&gt;
&lt;h5&gt;清单 2，数据结构 tm&lt;/h5&gt;
&lt;div class="codesection"&gt;

&lt;pre class="displaycode"&gt;struct tm {
int tm_sec; /* Seconds (0-60) */
int tm_min; /* Minutes (0-59) */ 
int tm_hour; /* Hours (0-23) */
int tm_mday; /* Day of the month (1-31) */
int tm_mon; /* Month (0-11) */
int tm_year; /* Year since 1900 */
int tm_wday; /* Day of the week (Sunday = 0)*/
int tm_yday; /* Day in the year (0-365; 1 Jan = 0)*/
int tm_isdst; /* Daylight saving time flag
 &gt; 0: DST is in effect;
 = 0: DST is not effect;
 &lt; 0: DST information not available */
};&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;可以使用 gmtime() 和 localtime() 把 time_t 转换为 tm 数据格式，其中 gmtime() 把时间转换为格林威治时间；localtime 则转换为当地时间。&lt;/p&gt;
&lt;h5&gt;清单 3，时间转换函数定义&lt;/h5&gt;
&lt;div class="codesection"&gt;

&lt;pre class="displaycode"&gt;#include &lt;time.h&gt;
struct tm *gmtime(const time_t *timep);
struct tm *localtime(const time_t *timep);&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;使用 tm 来表示时间，您就可以调用 asctime() 和 strftime() 将时间转换为字符串了。asctime() 的输出格式固定，和 ctime() 相同。strftime() 则类似我们最熟悉的 printf() 函数，您可以通过输入参数自定义时间的输出格式。&lt;/p&gt;
&lt;div class="codesection"&gt;

&lt;pre class="displaycode"&gt;size_t strftime(char *outstr, size_t maxsize, const char *format,
 const struct tm *timeptr);&lt;/pre&gt;

&lt;/div&gt;

&lt;h5&gt;清单 4，时间显示转换&lt;/h5&gt;
&lt;div class="codesection"&gt;

&lt;pre class="displaycode"&gt;int main ()
{
    time_t time_raw_format;
    struct tm * time_struct;
    char buf [100];
    time ( &amp;time_raw_format );
    time_struct = localtime ( &amp;time_raw_format );
    strftime (buf,100,"It is now: %I:%M%p.",time_struct);
    puts (buf);
    return 0;
}&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;该例子程序的输出结果如下：&lt;/p&gt;
&lt;div class="codesection"&gt;

&lt;pre class="displaycode"&gt;It is now: 02:45PM.&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;从以上的例子可以看到，利用从 time() 得到的时间值，可以调用各种转换函数将其转换成更方便人们阅读的形式。&lt;/p&gt;
&lt;p&gt;此外从前面的总结中我们也了解到，还有两个 C 函数可以获得当前时间，gettimeofday() 以及 clock_gettime()，它们分别返回 struct timeval 或者 timespec 代表的高精度的时间值。在目前的 GLibC 中，还没有直接把 struct timeval/timespec 转换为 struct tm 的函数。一般的做法是将 timeval 中的 tv_sec 转换为 tm，使用上面所述的方法转换为字符串，最后在显示的时候追加上 tv_usec，比如下面的例子代码：&lt;/p&gt;
&lt;h5&gt;清单 5，更多时间显示转换&lt;/h5&gt;
&lt;div class="codesection"&gt;

&lt;pre class="displaycode"&gt;struct timeval tv;
time_t nowtime; 
struct tm *nowtm; 
char tmbuf[64], buf[64]; 
gettimeofday(&amp;tv, NULL); //获取当前时间到 tv
nowtime = tv.tv_sec; //nowtime 存储了秒级的时间值
nowtm = localtime(&amp;nowtime); //转换为 tm 数据结构
//用 strftime 函数将 tv 转换为字符串，但 strftime 函数只能达到秒级精度
strftime(tmbuf, sizeof tmbuf, "%Y-%m-%d %H:%M:%S", nowtm);
//将毫秒值追加到 strftime 转换的字符串末尾 
snprintf(buf, sizeof buf, "%s.%06d", tmbuf, tv.tv_usec);&lt;/pre&gt;

&lt;/div&gt;

&lt;div class="ibm-alternate-rule"&gt;

* * *

&lt;/div&gt;

&lt;h2&gt;时间的测量&lt;/h2&gt;
&lt;p&gt;有时候我们要计算某段程序执行的时间，比如需要对算法进行时间分析。基本的实现思路为在被测试代码的开始和结束的地方获取当时时间，相减后得到相对值，即所需要的统计时间。为了实现高精度的时间测量，必须使用高精度的时间获取方式，一般有两种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统调用 gettimeofday&lt;/li&gt;
&lt;li&gt;汇编指令 RDTSC。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;gettimeofday&lt;/h3&gt;
&lt;p&gt;可以使用 gettimeofday() 函数进行时间测量，其精度在 us 级别，可以用来做一般的时间分析。&lt;/p&gt;
&lt;p&gt;gettimeofday() 将时间保存在结构 tv 之中。gettimeofday() 的第二个参数代表时区，在 Linux 中已经废弃不用，只能用 NULL 传入。一个典型的例子程序如下：&lt;/p&gt;
&lt;h5&gt;清单 6，gettimeofday 例子程序&lt;/h5&gt;
&lt;div class="codesection"&gt;

&lt;pre class="displaycode"&gt;void function() 
{ 
 unsigned int i,j; 
 double y; 
 for(i=0;i&lt;1000;i++) 
 for(j=0;j&lt;1000;j++) 
 y=sin((double)i); //耗时操作
} 

main() 
{ 
 struct timeval tpstart,tpend; 
 float timeuse; 

 gettimeofday(&amp;tpstart,NULL); //记录开始时间戳
 function(); 
 gettimeofday(&amp;tpend,NULL); //记录结束时间戳
 timeuse = 1000000*(tpend.tv_sec-tpstart.tv_sec)+ 
tpend.tv_usec-tpstart.tv_usec; //计算差值
 timeuse /= 1000000; 
 printf("Used Time:%f\n",timeuse); 
 exit(0); 
}&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;这个程序输出函数的执行时间，我们可以使用这个来进行系统性能的测试，或者是函数算法的效率分析。在我个人机器上的输出结果是：Used Time:0.556070&lt;/p&gt;
&lt;h3&gt;RDTSC&lt;/h3&gt;
&lt;p&gt;gettimeofday() 是一个系统调用，在某些场合下频繁调用它是不合适的。比如性能要求很高的代码段内。因为 gettimeofday() 需要用户态/内核态切换，开销较大。Intel X86 处理器提供了 TSC 硬件，并且可以用非特权指令 rdtsc 来读取该硬件的时间值，这就避免了过度的内核用户态切换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何使用 RDTSC&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考下面的例子代码，采用 GCC 的汇编扩展，定义 rdtsc 的函数，它返回当前时间戳。&lt;/p&gt;
&lt;div class="codesection"&gt;

&lt;pre class="displaycode"&gt;#define rdtsc(low,high) __asm__ \
 __volatile__("rdtsc" : "=a" (low), "=d" (high))&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;在 C 代码中使用 rdtsc 十分简单。比如：&lt;/p&gt;
&lt;h5&gt;清单 7，RDTSC 例子程序&lt;/h5&gt;
&lt;div class="codesection"&gt;

&lt;pre class="displaycode"&gt;unsigned long long get_cycles()
{
    unsigned low, high;
    unsigned long long val;
    rdtsc(low,high);
    val = high;
val = (val &lt;&lt; 32) | low; //将 low 和 high 合成一个 64 位值
    return val;
}

double get_cpu_mhz(void)
{
    FILE* f;
    char buf[256];
    double mhz = 0.0;

f = fopen("/proc/cpuinfo","r"); //打开 proc/cpuinfo 文件
    if (!f)
        return 0.0;
    while(fgets(buf, sizeof(buf), f)) {
        double m;
        int rc;
rc = sscanf(buf, "cpu MHz : %lf", &amp;m); //读取 cpu MHz
        if (mhz == 0.0) {
            mhz = m;
            break;
        }
    }
    fclose(f);
return mhz; //返回 HZ 值
}

int main()
{
    double mhz;
    mhz = get_cpu_mhz();
    cycles_t c1, c2;

    for(;;)
    {
        c1 = get_cycles(); 
        sleep(1);
        c2 = get_cycles();
 //c2 和 c1 的差值应该为 1000000us，即 1 秒
        printf("1 sec = %g usec\n", (c2 - c1) / mhz); 
    }
}&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;函数 get_cycles 将返回 64 位整数，代表当前时间，单位是 CPU 的 cycle 数。函数 get_cpu_mhz 获得当前 CPU 的工作频率。用两个 CPU cycle 的差值除以 CPU 频率，就是微妙。&lt;/p&gt;
&lt;p&gt;但 RDTSC 只能在 IA 系列处理器上使用。而且由于处理器的乱序执行，RDTSC 有些情况下并不准确，在 SMP 下使用 RDTSC 也有一定的问题。但这些问题只有在需要极高时间精度的情况下才会出现，对于一般的时间测量要求，采用 RDTSC 是一个可以考虑的选择。&lt;/p&gt;
&lt;div class="ibm-alternate-rule"&gt;

* * *

&lt;/div&gt;

&lt;h2&gt;计时器的使用&lt;/h2&gt;
&lt;p&gt;有时我们需要定时完成一些任务。简单的方法是使用 while 循环加 sleep。比如每隔 1 分钟检查链接情况的 heartbeat 任务等。&lt;/p&gt;
&lt;h5&gt;清单 8，sleep 加循环&lt;/h5&gt;
&lt;div class="codesection"&gt;

&lt;pre class="displaycode"&gt;while(condtion)
{
 //do something
 sleep(interval);
}&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;这可以满足很多程序的定时需要，但假如您不希望程序“偷懒”，即上例中 sleep 的时候您还是希望程序做些有用的工作，那么使用定时器是通常的选择。Linux 系统上最常用的定时器是 setitmer 计时器。&lt;/p&gt;
&lt;h3&gt;setitimer&lt;/h3&gt;
&lt;p&gt;Linux 为每一个进程提供了 3 个 setitimer 间隔计时器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ITIMER_REAL：减少实际时间，到期的时候发出 SIGALRM 信号。&lt;/li&gt;
&lt;li&gt;ITIMER_VIRTUAL：减少有效时间 (进程执行的时间)，产生 SIGVTALRM 信号。&lt;/li&gt;
&lt;li&gt;ITIMER_PROF：减少进程的有效时间和系统时间 (为进程调度用的时间)。这个经常和上面一个使用用来计算系统内核时间和用户时间。产生 SIGPROF 信号。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所谓 REAL 时间，即我们人类自然感受的时间，英文计算机文档中也经常使用 wall-clock 这个术语。说白了就是我们通常所说的时间，比如现在是下午 5 点 10 分，那么一分钟的 REAL 时间之后就是下午 5 点 11 分。&lt;/p&gt;
&lt;p&gt;VIRTUAL 时间是进程执行的时间，Linux 是一个多用户多任务系统，在过去的 1 分钟内，指定进程实际在 CPU 上的执行时间往往并没有 1 分钟，因为其他进程会被 Linux 调度执行，在那些时间内，虽然自然时间在流逝，但指定进程并没有真正的运行。VIRTUAL 时间就是指定进程真正的有效执行时间。比如 5 点 10 分开始的 1 分钟内，进程 P1 被 Linux 调度并占用 CPU 的执行时间为 30 秒，那么 VIRTUAL 时间对于进程 P1 来讲就是 30 秒。此时自然时间已经到了 5 点 11 分，但从进程 P1 的眼中看来，时间只过了 30 秒。&lt;/p&gt;
&lt;p&gt;PROF 时间比较独特，对进程 P1 来说从 5 点 10 分开始的 1 分钟内，虽然自己的执行时间为 30 秒，但实际上还有 10 秒钟内核是在执行 P1 发起的系统调用，那么这 10 秒钟也被加入到 PROF 时间。这种时间定义主要用于全面衡量进程的性能，因为在统计程序性能的时候，10 秒的系统调用时间也应该算到 P1 的头上。这也许就是 PROF 这个名字的来历吧。&lt;/p&gt;
&lt;p&gt;使用 setitimer Timer 需要了解下面这些接口 API:&lt;/p&gt;
&lt;div class="codesection"&gt;

&lt;pre class="displaycode"&gt;int getitimer(int which,struct itimerval *value); 
int setitimer(int which,struct itimerval *newval, 
struct itimerval *oldval);&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;itimerval 的定义如下：&lt;/p&gt;
&lt;div class="codesection"&gt;

&lt;pre class="displaycode"&gt;struct itimerval { 
struct timeval it_interval; 
struct timeval it_value; 
}&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;getitimer 函数得到间隔计时器的时间值，保存在 value 中。&lt;/p&gt;
&lt;p&gt;setitimer 函数设置间隔计时器的时间值为 newval. 并将旧值保存在 oldval 中；which 表示使用三个计时器中的哪一个。&lt;/p&gt;
&lt;p&gt;itimerval 结构中的 it_value 是第一次调用后触发定时器的时间，当这个值递减为 0 时，系统会向进程发出相应的信号。此后将以 it_internval 为周期定时触发定时器。&lt;/p&gt;
&lt;p&gt;给出一个具体的例子：&lt;/p&gt;
&lt;h5&gt;清单 9，setitmer 例子&lt;/h5&gt;
&lt;p&gt;这个程序使用 PROF 时间，每经过两秒 PROF 时间之后就会打印一下 &lt;code&gt;timer fired&lt;/code&gt; 字符串。&lt;/p&gt;
&lt;p&gt;需要指出：setitimer 计时器的精度为 ms，即 1000 分之 1 秒，足以满足绝大多数应用程序的需要。但多媒体等应用可能需要更高精度的定时，那么就需要考虑使用下一类定时器：POSIX Timer。&lt;/p&gt;
&lt;h3&gt;POSIX Timer&lt;/h3&gt;
&lt;p&gt;间隔定时器 setitimer 有一些重要的缺点，POSIX Timer 对 setitimer 进行了增强，克服了 setitimer 的诸多问题：&lt;/p&gt;
&lt;p&gt;首先，一个进程同一时刻只能有一个 timer。假如应用需要同时维护多个 Interval 不同的计时器，必须自己写代码来维护。这非常不方便。使用 POSIX Timer，一个进程可以创建任意多个 Timer。&lt;/p&gt;
&lt;p&gt;setitmer 计时器时间到达时，只能使用信号方式通知使用 timer 的进程，而 POSIX timer 可以有多种通知方式，比如信号，或者启动线程。&lt;/p&gt;
&lt;p&gt;使用 setitimer 时，通知信号的类别不能改变：SIGALARM，SIGPROF 等，而这些都是传统信号，而不是实时信号，因此有 timer overrun 的问题；而 POSIX Timer 则可以使用实时信号。&lt;/p&gt;
&lt;p&gt;setimer 的精度是 ms，POSIX Timer 是针对有实时要求的应用所设计的，接口支持 ns 级别的时钟精度。&lt;/p&gt;
&lt;h5&gt;表 2. POSIX Timer 函数&lt;/h5&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;函数名&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;功能&lt;/strong&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;timer_create&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;创建一个新的 Timer；并且指定定时器到时通知机制&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;timer_delete&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;删除一个 Timer&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;timer_gettime&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Get the time remaining on a POSIX.1b interval timer&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;timer_settime&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;开始或者停止某个定时器。&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;timer_getoverrun&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;获取丢失的定时通知个数。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;使用 Posix Timer 的基本流程很简单，首先创建一个 Timer。创建的时候可以指定该 Timer 的一些特性，比如 clock ID。&lt;/p&gt;
&lt;p&gt;clock ID 即 Timer 的种类，可以为下表中的任意一种：&lt;/p&gt;
&lt;h5&gt;表 3. POSIX Timer clock ID&lt;/h5&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Clock ID&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;CLOCK_REALTIME&lt;/td&gt;
&lt;td&gt;Settable system-wide real-time clock；&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CLOCK_MONOTONIC&lt;/td&gt;
&lt;td&gt;Nonsettable monotonic clock&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CLOCK_PROCESS_CPUTIME_ID&lt;/td&gt;
&lt;td&gt;Per-process CPU-time clock&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CLOCK_THREAD_CPUTIME_ID&lt;/td&gt;
&lt;td&gt;Per-thread CPU-time clock&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;CLOCK_REALTIME 时间是系统保存的时间，即可以由 date 命令显示的时间，该时间可以重新设置。比如当前时间为上午 10 点 10 分，Timer 打算在 10 分钟后到时。假如 5 分钟后，我用 date 命令修改当前时间为 10 点 10 分，那么 Timer 还会再等十分钟到期，因此实际上 Timer 等待了 15 分钟。假如您希望无论任何人如何修改系统时间，Timer 都严格按照 10 分钟的周期进行触发，那么就可以使用 CLOCK_MONOTONIC。&lt;/p&gt;
&lt;p&gt;CLOCK_PROCESS_CPUTIME_ID 的含义与 setitimer 的 ITIMER_VIRTUAL 类似。计时器只记录当前进程所实际花费的时间；比如还是上面的例子，假设系统非常繁忙，当前进程只能获得 50%的 CPU 时间，为了让进程真正地运行 10 分钟，应该到 10 点 30 分才允许 Timer 到期。&lt;/p&gt;
&lt;p&gt;CLOCK_THREAD_CPUTIME_ID 以线程为计时实体，当前进程中的某个线程真正地运行了一定时间才触发 Timer。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设置到期通知方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;timer_create 的第二个参数 struct sigevent 用来设置定时器到时时的通知方式。该数据结构如下：&lt;/p&gt;
&lt;h5&gt;清单 10，结构 sigevent&lt;/h5&gt;
&lt;p&gt;其中 sigev_notify 表示通知方式，有如下几种：&lt;/p&gt;
&lt;h5&gt;表 3. POSIX Timer 到期通知方式&lt;/h5&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;通知方式&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SIGEV_NONE&lt;/td&gt;
&lt;td&gt;定时器到期时不产生通知。。。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SIGEV_SIGNAL&lt;/td&gt;
&lt;td&gt;定时器到期时将给进程投递一个信号，sigev_signo 可以用来指定使用什么信号。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SIGEV_THREAD&lt;/td&gt;
&lt;td&gt;定时器到期时将启动新的线程进行需要的处理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SIGEV_THREAD_ID（仅针对 Linux)&lt;/td&gt;
&lt;td&gt;定时器到期时将向指定线程发送信号。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果采用 SIGEV_NONE 方式，使用者必须调用&lt;code&gt;timer_gettime 函数主动读取定时器已经走过的时间。类似轮询。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果采用 SIGEV_SIGNAL 方式，使用者可以选择使用什么信号，用 sigev_signo 表示信号值，比如 SIG_ALARM。&lt;/p&gt;
&lt;p&gt;如果使用 SIGEV_THREAD 方式，则需要设置 sigev_notify_function，当 Timer 到期时，将使用该函数作为入口启动一个线程来处理信号；sigev_value 保存了传入 sigev_notify_function 的参数。sigev_notify_attributes 如果非空，则应该是一个指向 pthread_attr_t 的指针，用来设置线程的属性（比如 stack 大小,detach 状态等）。&lt;/p&gt;
&lt;p&gt;SIGEV_THREAD_ID 通常和 SIGEV_SIGNAL 联合使用，这样当 Timer 到期时，系统会向由 sigev_notify_thread_id 指定的线程发送信号，否则可能进程中的任意线程都可能收到该信号。这个选项是 Linux 对 POSIX 标准的扩展，目前主要是 GLibc 在实现 SIGEV_THREAD 的时候使用到，应用程序很少会需要用到这种模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;启动定时器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建 Timer 之后，便可以调用 timer_settime() 函数指定定时器的时间间隔，并启动该定时器了。&lt;/p&gt;
&lt;p&gt;第一次看到 timer_settime 的参数列表或许会令人觉得费解。先来看看 new_value 和 old_value，它们都是 struct itimerspec 数据结构。&lt;/p&gt;
&lt;div class="codesection"&gt;

&lt;pre class="displaycode"&gt;struct itimerspec
{
 struct timespec it_interval; //定时器周期值
 struct timespec it_value; //定时器到期值
};&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;启动和停止 Timer 都可以通过设置 new_value 来实现：&lt;/p&gt;
&lt;p&gt;new_value-&amp;gt;it_interval 为定时器的周期值，比如 1 秒，表示定时器每隔 1 秒到期；&lt;/p&gt;
&lt;p&gt;new_value-&amp;gt;it_value 如果大于 0，表示启动定时器，Timer 将在 it_value 这么长的时间过去后到期，此后每隔 it_interval 便到期一次。如果 it_value 为 0，表示停止该 Timer。&lt;/p&gt;
&lt;p&gt;有些时候，应用程序会先启动用一个时间间隔启动定时器，随后又修改该定时器的时间间隔，这都可以通过修改 new_value 来实现；假如应用程序在修改了时间间隔之后希望了解之前的时间间隔设置，则传入一个非 NULL 的 old_value 指针，这样在 timer_settime() 调用返回时，old_value 就保存了上一次 Timer 的时间间隔设置。多数情况下我们并不需要这样，便可以简单地将 old_value 设置为 NULL，忽略它。&lt;/p&gt;
&lt;p&gt;下面给出一个使用 posix timer 的例子程序。最传统的例子就是创建通知方式为 SIGEV_SIGNAL 的 Timer。这样当定时器到期时，将产生信号通知，主程序需要定义自己的信号处理函数，来处理信号到期事件。这种例子比比皆是，我打算在这里写一个采用通知方式为 SIGEV_THREAD 的例子。该例子程序从 main 函数开始主线程，在开始的时候打印出主线程的进程 ID 和线程 ID。&lt;/p&gt;
&lt;h5&gt;清单 11，打印 TID&lt;/h5&gt;
&lt;div class="codesection"&gt;

&lt;pre class="displaycode"&gt; pid_t tid = (pid_t) syscall (SYS_gettid);
 printf("start program in PID:[%d]TID:[%d]\n",getpid(),tid);&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;获得 ThreadID 的系统调用尚未被 GLibC 标准化，因此这里直接调用 syscall。&lt;/p&gt;
&lt;p&gt;然后，主线程初始化创建 Timer 所需要的数据结构：&lt;/p&gt;
&lt;h5&gt;清单 12，设置通知方式&lt;/h5&gt;
&lt;div class="codesection"&gt;

&lt;pre class="displaycode"&gt; se.sigev_notify = SIGEV_THREAD;
 se.sigev_value.sival_ptr = &amp;timer_id;
 se.sigev_notify_function = timer_thread;
 se.sigev_notify_attributes = NULL;
 status = timer_create(CLOCK_REALTIME, &amp;se, &amp;timer_id);&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;这里将通知方式设为 SIGEV_THREAD，timer_thread 为线程入口函数。&lt;/p&gt;
&lt;p&gt;然后主线程设置定时器间隔，并启动 Timer：&lt;/p&gt;
&lt;h5&gt;清单 13，启动 Timer&lt;/h5&gt;
&lt;div class="codesection"&gt;

&lt;pre class="displaycode"&gt; ts.it_value.tv_sec = 5;
 ts.it_value.tv_nsec = 0;
 ts.it_interval.tv_sec = 5;
 ts.it_interval.tv_nsec = 0;
 status = timer_settime(timer_id, 0, &amp;ts, 0);&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;此后主线程进入一个循环，在循环中等待线程条件变量：&lt;/p&gt;
&lt;h5&gt;清单 14，主程序中的循环&lt;/h5&gt;
&lt;div class="codesection"&gt;

&lt;pre class="displaycode"&gt; while (counter &lt; 5) {
 status = pthread_cond_wait (&amp;cond, &amp;mutex);
}&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;条件变量 cond 将在 timer_thread() 处理函数中触发，这样每 5 秒钟，定时器将调用 timer_thread() 处理函数，并唤醒主线程等待的条件变量一次。5 次之后测试程序退出。&lt;/p&gt;
&lt;p&gt;现在我们看看 timer_thread() 函数：&lt;/p&gt;
&lt;h5&gt;清单 15，timer_thread 函数&lt;/h5&gt;
&lt;div class="codesection"&gt;

&lt;pre class="displaycode"&gt;void timer_thread (void *arg)
{
 status = pthread_mutex_lock (&amp;mutex);
 if (++counter &gt;= 5) {
 status = pthread_cond_signal (&amp;cond);
 }
 status = pthread_mutex_unlock (&amp;mutex);
 pid_t tid = (pid_t) syscall (SYS_gettid);
 printf ("Timer %d in PID:[%d]TID:[%d]\n", counter,getpid(),tid);
}&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;在整个程序中我们都没有使用信号，定时器到期时，将启动新的线程运行 timer_thread。因此在该函数中，我们还打印了当前的线程号以便可以看出它们确实在不同线程中运行。&lt;/p&gt;
&lt;p&gt;这里是运行该程序的一个输出：&lt;/p&gt;
&lt;div class="codesection"&gt;

&lt;pre class="displaycode"&gt;-bash-3.2$ gcc threadtimer.c -lrt -lpthread -o test
-bash-3.2$ ./test
start program in PID:[21483]TID:[21483]
Timer 1 in PID:[21483]TID:[21498]
Timer 2 in PID:[21483]TID:[21510]
Timer 3 in PID:[21483]TID:[21534]&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;可以看到每次 Timer 都运行在不同的线程中。&lt;/p&gt;
&lt;div class="ibm-alternate-rule"&gt;

* * *

&lt;/div&gt;

&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;至此，希望我已经讲述了 Linux 系统提供的大多数关于时间的编程方法。使用这些方法我们可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获得当前时间，并转换为合适的显示方式；&lt;/li&gt;
&lt;li&gt;衡量程序运行经过的时间；&lt;/li&gt;
&lt;li&gt;使用定时器完成周期性的任务；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外不知道您是否和我一样，对于 Linux 系统如何实现这些机制十分好奇。计算机毕竟是一个机器，底层硬件提供了怎样的功能，操作系统和 C 库如何协同工作才可以提供这些一丝不苟的，优美的方法呢？我将在后续的部分试图探讨这个话题。&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">muou</dc:creator><pubDate>Fri, 15 Jul 2016 10:00:00 +0800</pubDate><guid>tag:muou55555.github.com,2016-07-15:content/articles/2016/07/15/linux timer/</guid><category>linux</category><category>C</category></item><item><title>Markdown中使用MathJax引擎显示数学公式</title><link>https://muou55555.github.com/content/articles/2016/01/14/markdown_math/</link><description>&lt;script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"&gt;&lt;/script&gt;

&lt;p&gt;在工作中，我们经常会用到一些数学公式，如何把这些数学公式显示在文章中，可以利用Markdown+MathJax完成在文章中显示各种数学公式。&lt;br&gt;
Markdown的语法网上有很多，这里就不做重述。&lt;br&gt;
MathJax是一款运行在浏览器中的开源的数学符号渲染引擎，使用MathJax可以方便的在浏览器中显示数学公式，不需要使用图片。可以解析LaTex、MathML和ASCIIMathMl的标记语言。&lt;br&gt;&lt;/p&gt;
&lt;h3&gt;参考资料&lt;/h3&gt;
&lt;p&gt;MathJax官网: &lt;a href="https://www.mathjax.org/"&gt;https://www.mathjax.org/&lt;/a&gt;  &lt;br&gt;
MathJax源码: &lt;a href="https://github.com/mathjax/"&gt;https://github.com/mathjax/&lt;/a&gt;  &lt;br&gt;
&lt;a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference"&gt;MathJax使用说明&lt;/a&gt;&lt;br&gt;
Latex在线编辑器: &lt;a href="http://latex.codecogs.com/eqneditor/editor.php"&gt;http://latex.codecogs.com/eqneditor/editor.php&lt;/a&gt; &lt;br&gt;&lt;/p&gt;
&lt;h3&gt;使用方法&lt;/h3&gt;
&lt;h4&gt;规则&lt;/h4&gt;
&lt;p&gt;显示方式分为两种，一种是行内，写在&lt;code&gt;\...\&lt;/code&gt;内；另一种是行间,写在&lt;code&gt;$$...$$&lt;/code&gt;&lt;br&gt;
&lt;code&gt;Tips:&lt;/code&gt; 我试了下在markdown中写在&lt;code&gt;$$...$$&lt;/code&gt;只能在一行中显示，需要在多行时显示，可以放在&lt;code&gt;&amp;lt;div&amp;gt;...&amp;lt;/div&amp;gt;&lt;/code&gt;之间。&lt;br&gt;&lt;/p&gt;
&lt;h4&gt;步骤&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;在文档头部加入&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; &lt;span class="nt"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;text/javascript&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以把MathJax下载到本地: &lt;code&gt;git clone git://github.com/mathjax/MathJax.git&lt;/code&gt;，然后把src连接转换到本地地址。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;然后可以使用Latex在线编辑器进行数学公式编写，然后把结果复制到markdown中即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;行间
$$x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}$$
行内 \(x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}\)&lt;/p&gt;
&lt;p&gt;行间
$$\lim_{n \rightarrow +\infty} \frac{1}{n(n+1)}$$
行内 \(lim_{n \rightarrow +\infty} \frac{1}{n(n+1)}\)&lt;/p&gt;
&lt;p&gt;带括号的矩阵&lt;/p&gt;
&lt;div&gt;
\begin{pmatrix}
a_{11} &amp; \cdots &amp; a_{1n}\\
\vdots &amp; \ddots &amp; \vdots\\
a_{m1} &amp; \cdots &amp; a_{mn}
\end{pmatrix}
&lt;/div&gt;

&lt;div&gt;
\begin{pmatrix}
1&amp;0\\
0&amp;1
\end{pmatrix}
&lt;/div&gt;

&lt;p&gt;不带括号的&lt;/p&gt;
&lt;div&gt;
\begin{matrix} 
1 &amp; x &amp; x^2 \\
1 &amp; y &amp; y^2 \\
1 &amp; z &amp; z^2 
\end{matrix}
&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">muou</dc:creator><pubDate>Thu, 14 Jan 2016 15:25:00 +0800</pubDate><guid>tag:muou55555.github.com,2016-01-14:content/articles/2016/01/14/markdown_math/</guid><category>Markdown</category></item><item><title>利用libnet进行TCP会话劫持</title><link>https://muou55555.github.com/content/articles/2016/01/12/tcphijack/</link><description>&lt;h3&gt;相关知识&lt;/h3&gt;
&lt;p&gt;会话劫持（Session Hijack）: 就是结合了嗅探以及欺骗技术在内的攻击手段。例如，在一次正常的会话过程当中，攻击者作为第三方参与到其中，他可以在正常数据包中插入恶意数据，也可以在双方的会话当中进行监听，甚至可以是代替某一方主机接管会话。
&lt;br&gt;
可以把会话劫持攻击分为两种类型:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中间人攻击(Man In The Middle，简称MITM)&lt;/li&gt;
&lt;li&gt;注射式攻击（Injection）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;既然是进行TCP劫持，则先要对TCP/IP协议相关知识有个初步的了解。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP/IP数据封装&lt;br&gt;
&lt;div&gt; 
&lt;img style="border-radius: 1%; display: block;" width = "350px" height = "350px" src="/images/http/tcpipdata.png" alt="1"/&gt;
&lt;/div&gt; &lt;/li&gt;
&lt;li&gt;IP数据包格式&lt;br&gt;
&lt;div&gt; 
&lt;img style="border-radius: 1%; display: block;" width = "350px" height = "350px" src="/images/http/ipdata.gif" alt="1"/&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;TCP建立连接过程&lt;br&gt;
&lt;div&gt; 
&lt;img style="border-radius: 1%; display: block;" width = "350px" height = "300px" src="/images/http/tcpcnt.jpg" alt="1"/&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;原理&lt;/h3&gt;
&lt;h4&gt;注射式攻击&lt;/h4&gt;
&lt;p&gt;这种方式的会话劫持比中间人攻击实现起来简单一些，它不会改变会话双方的通讯流，而是在双方正常的通讯中流插入恶意数据。在注射式攻击中，需要实现两种技术：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IP欺骗；&lt;/li&gt;
&lt;li&gt;预测TCP序列号。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于IP欺骗，有两种情况需要用到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;隐藏自己的IP地址；&lt;/li&gt;
&lt;li&gt;利用两台机器之间的信任关系实施入侵。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Unix/Linux平台上，可以直接使用Socket构造IP包，在IP头中填上虚假的IP地址，但需要root权限；在Windows平台上，不能使用Winsock，需要使用Winpacp（也可以使用Libnet）。例如在Linux系统，首先打开一个Raw Socket（原始套接字），然后自己编写IP头及其他数据。
TCP协议的注射式会话劫持，攻击者应先采用嗅探技术对目标进行监听，然后从监听到的信息中构造出正确的序列号，如果不这样，你就必须先猜测目标的ISN（初始序列号），这样无形中对会话劫持加大了难度。&lt;/p&gt;
&lt;h4&gt;中间人攻击MITM&lt;/h4&gt;
&lt;p&gt;要想正确的实施中间人攻击，攻击者首先需要使用ARP欺骗或DNS欺骗，将会话双方的通讯流暗中改变，而这种改变对于会话双方来说是一个完全透明的代理，可以得到一切想知道的信息，甚至是利用一些有缺陷的加密协议来实现。 &lt;/p&gt;
&lt;h3&gt;libnet&lt;/h3&gt;
&lt;p&gt;libnet是一个开源的接口函数库，主要用C语言实现，提供了底层网络数据包的构造、处理和发送功能。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tips&lt;/code&gt; 实际实现过程中，会用libpcap进行监控，用libnet进行构造数据包&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;libnet主要流程
&lt;div&gt; 
&lt;img style="border-radius: 1%; display: block;" width = "400px" height = "260px" src="/images/http/libnet.png" alt="1"/&gt;
&lt;/div&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;源码&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下载地址: &lt;a href="http://sourceforge.net/projects/libnet-dev/"&gt;libnet&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;DEMO部分代码&lt;/h3&gt;
&lt;p&gt;对http会话协议报文的篡改，实现基本的302重定向功能&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="c1"&gt;//初始化libnet，每个线程一个libnet &lt;/span&gt;
    &lt;span class="n"&gt;init_thread_libnet&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="c1"&gt;//http重定向&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ip_head&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;protocol&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;IPPROTO_TCP&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;tcp_head&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;dest&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;HTTP_PORT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;u_int8_t&lt;/span&gt; &lt;span class="n"&gt;tcp_flags&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;libnet_tcp_hdr&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;tcp_head&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;th_flags&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tcp_flags&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;TH_SYN&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nl"&gt;TODO:&lt;/span&gt; &lt;span class="err"&gt;回复一个&lt;/span&gt;&lt;span class="n"&gt;syn&lt;/span&gt; &lt;span class="n"&gt;ack&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tcp_flags&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TH_ACK&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;TH_SYN&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nl"&gt;TODO:&lt;/span&gt; &lt;span class="err"&gt;伪造&lt;/span&gt;&lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="err"&gt;响应报文。这里是&lt;/span&gt;&lt;span class="mi"&gt;302&lt;/span&gt;&lt;span class="err"&gt;重定向&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tcp_flags&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TH_FIN&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;TH_RST&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nl"&gt;TODO:&lt;/span&gt; &lt;span class="err"&gt;结束链接&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;伪造所用的http head&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;static&lt;/span&gt; &lt;span class="nx"&gt;u_int8_t&lt;/span&gt; &lt;span class="nx"&gt;httphead_t&lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; =
&amp;quot;HTTP/1.0 302 Found\n&amp;quot;
&amp;quot;Location: %s\n&amp;quot;
&amp;quot;Connection:close\n\n&amp;quot;
&amp;quot;&lt;span class="nt"&gt;&amp;lt;html&amp;gt;&lt;/span&gt;\n\t&lt;span class="nt"&gt;&amp;lt;head&amp;gt;&lt;/span&gt;\n\t\t&lt;span class="nt"&gt;&amp;lt;meta&lt;/span&gt; &lt;span class="na"&gt;http-equiv=&lt;/span&gt;&lt;span class="s"&gt;\&amp;quot;Refresh\&amp;quot;content=\&amp;quot;0;&amp;quot;&lt;/span&gt;
&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="na"&gt;url=&lt;/span&gt;&lt;span class="s"&gt;%s\&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;\n\t&lt;span class="nt"&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;\n&lt;span class="nt"&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;\n&amp;quot;;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;结束语&lt;/h3&gt;
&lt;p&gt;只有在了解别人攻击手段之后，我们才能做好网络安全的防范措施。&lt;br&gt;
后续会在研究https会话劫持技术&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">muou</dc:creator><pubDate>Tue, 12 Jan 2016 22:25:00 +0800</pubDate><guid>tag:muou55555.github.com,2016-01-12:content/articles/2016/01/12/tcphijack/</guid><category>Http</category><category>Tcp</category></item><item><title>How to C in 2016</title><link>https://muou55555.github.com/content/articles/2016/01/11/howtoc/</link><description>&lt;p&gt;&lt;code&gt;Forward link&lt;/code&gt; &lt;a href="https://matt.sh/howto-c"&gt;https://matt.sh/howto-c&lt;/a&gt;&lt;br&gt;
This is a draft I wrote in early 2015 and never got around to publishing. Here's the mostly unpolished version because it wasn't doing anybody any good sitting in my drafts folder. The simplest change was updating year 2015 to 2016 at publication time.&lt;/p&gt;
&lt;p&gt;Feel free to submit fixes/improvements/complaints as necessary. -Matt&lt;/p&gt;
&lt;p&gt;Adrián Arroyo Calle provides a Spanish translation at ?Cómo programar en C (en 2016)?&lt;/p&gt;
&lt;p&gt;Keith Thompson provides a nice set of corrections and alternative opinions at howto-c-response.&lt;/p&gt;
&lt;p&gt;Now on to the article...&lt;/p&gt;
&lt;p&gt;The first rule of C is don't write C if you can avoid it.&lt;/p&gt;
&lt;p&gt;If you must write in C, you should follow modern rules.&lt;/p&gt;
&lt;p&gt;C has been around since the early 1970s. People have "learned C" at various points during its evolution, but knowledge usually get stuck after learning, so everybody has a different set of things they believe about C based on the year(s) they first started learning.&lt;/p&gt;
&lt;p&gt;It's important to not remain stuck in your "things I learned in the 80s/90s" mindset of C development.&lt;/p&gt;
&lt;p&gt;This page assumes you are on a modern platform conforming to modern standards and you have no excessive legacy compatibility requirements. We shouldn't be globally tied to ancient standards just because some companies refuse to upgrade 20 year old systems.&lt;/p&gt;
&lt;p&gt;Preflight
Standard c99 (c99 means "C Standard from 1999"; c11 means "C Standard from 2011", so 11 &amp;gt; 99).&lt;/p&gt;
&lt;p&gt;clang, default
clang uses an extended version of C11 by default (GNU C11 mode), so no extra options are needed for modern features.
If you want standard C11, you need to specify -std=c11; if you want standard C99, use -std=c99.
clang compiles your source files faster than gcc
gcc requires you specify -std=c99 or -std=c11
gcc builds source files slower than clang, but sometimes generates faster code. Performance comparisons and regression testings are important.
gcc-5 defaults to GNU C11 mode (same as clang), but if you need exactly c11 or c99, you should still specify -std=c11 or -std=c99.
Optimizations&lt;/p&gt;
&lt;p&gt;-O2, -O3
generally you want -O2, but sometimes you want -O3. Test under both levels (and across compilers) then keep the best performing binaries.
-Os
-Os helps if your concern is cache efficiency (which it should be)
Warnings&lt;/p&gt;
&lt;p&gt;-Wall -Wextra -pedantic
newer compiler versions have -Wpedantic, but they still accept the ancient -pedantic as well for wider backwards compatibility.
during testing you should add -Werror and -Wshadow on all your platforms
it can be tricky deploying production source using -Werror because different platforms and compilers and libraries can emit different warnings. You probably don't want to kill a user's entire build just because their version of GCC on a platform you've never seen complains in new and wonderous ways.
extra fancy options include -Wstrict-overflow -fno-strict-aliasing
Either specify -fno-strict-aliasing or be sure to only access objects as the type they have at creation. Since so much existing C code aliases across types, using -fno-strict-aliasing is a much safer bet if you don't control the entire underlying source tree.
as of now, Clang reports some valid syntax as a warning, so you should add -Wno-missing-field-initializers
GCC fixed this unnecessary warning after GCC 4.7.0
Building&lt;/p&gt;
&lt;p&gt;Compilation units
The most common way of building C projects is to decompose every source file into an object file then link all the objects together at the end. This procedure works great for incremental development, but it is suboptimal for performance and optimization. Your compiler can't detect potential optimization across file boundaries this way.
LTO — Link Time Optimization
LTO fixes the "source analysis and optimization across compilation units problem" by annotating object files with intermediate representation so source-aware optimizations can be carried out across compilation units at link time (this slows down the linking process noticeably, but make -j helps).
clang LTO (guide)
gcc LTO
As of 2016, clang and gcc releases support LTO by just adding -flto to your command line options during object compilation and final library/program linking.
LTO still needs some babysitting though. Sometimes, if your program has code not used directly but used by additional libraries, LTO can evict functions or code because it detects, globally when linking, some code is unused/unreachable and doesn't need to be included in the final linked result.
Arch&lt;/p&gt;
&lt;p&gt;-march=native
give the compiler permission to use your CPU's full feature set
again, performance testing and regression testing is important (then comparing the results across multiple compilers and/or compiler versions) is important to make sure any enabled optimizations don't have adverse side effects.
-msse2 and -msse4.2 may be useful if you need to target not-your-build-machine features.
Writing code
Types
If you find yourself typing char or int or short or long or unsigned into new code, you're doing it wrong.&lt;/p&gt;
&lt;p&gt;For modern programs, you should #include &lt;stdint.h&gt; then use standard types.&lt;/p&gt;
&lt;p&gt;The common standard types are:&lt;/p&gt;
&lt;p&gt;int8_t, int16_t, int32_t, int64_t — signed integers
uint8_t, uint16_t, uint32_t, uint64_t — unsigned integers
float — standard 32-bit floating point
double - standard 64-bit floating point
Notice we don't have char anymore. char is actually misnamed and misused in C.&lt;/p&gt;
&lt;p&gt;Developers routinely abuse char to mean "byte" even when they are doing unsigned byte manipulations. It's much cleaner to use uint8_t to mean single a unsigned-byte/octet-value and uint8_t * to mean sequence-of-unsigned-byte/octet-values.&lt;/p&gt;
&lt;p&gt;One Exception to never-char&lt;/p&gt;
&lt;p&gt;The only acceptable use of char in 2016 is if a pre-existing API requires char (e.g. strncat, printf'ing "%s", ...) or if you're initializing a read-only string (e.g. const char *hello = "hello";) because the C type of string literals ("hello") is char [].&lt;/p&gt;
&lt;p&gt;ALSO: In C11 we have native unicode support, and the type of UTF-8 string literals is still char * even for multibyte sequences like const char *abcgrr = u8"abc??";.&lt;/p&gt;
&lt;p&gt;Signedness&lt;/p&gt;
&lt;p&gt;At no point should you be typing the word unsigned into your code. We can now write code without the ugly C convention of multi-word types that impair readability as well as usage. Who wants to type unsigned long long int when you can type uint64_t? The &lt;stdint.h&gt; types are more explicit, more exact in meaning, convey intentions better, and are more compact for typographic usage and readability.&lt;/p&gt;
&lt;p&gt;But, you may say, "I need to cast pointers to long for dirty pointer math!"&lt;/p&gt;
&lt;p&gt;You may say that. But you are wrong.&lt;/p&gt;
&lt;p&gt;The correct type for pointer math is uintptr_t defined in &lt;stdint.h&gt;, while the also useful ptrdiff_t is defined in stddef.h.&lt;/p&gt;
&lt;p&gt;Instead of:&lt;/p&gt;
&lt;p&gt;long diff = (long)ptrOld - (long)ptrNew;
Use:&lt;/p&gt;
&lt;p&gt;ptrdiff_t diff = (uintptr_t)ptrOld - (uintptr_t)ptrNew;
Also:&lt;/p&gt;
&lt;p&gt;printf("%p is unaligned by %" PRIuPTR " bytes.\n", (void &lt;em&gt;)p, ((uintptr_t)somePtr &amp;amp; (sizeof(void &lt;/em&gt;) - 1)));
System-Dependent Types&lt;/p&gt;
&lt;p&gt;You continue arguing, "on a 32 bit platform I want 32 bit longs and on a 64 bit platform I want 64 bit longs!"&lt;/p&gt;
&lt;p&gt;If we skip over the line of thinking where you are deliberately introducing difficult to reason about code by using two different sizes depending on platform, you still don't want to use long for system-dependent types.&lt;/p&gt;
&lt;p&gt;In these situations, you should use intptr_t — the integer type defined to be the word size of your current platform.&lt;/p&gt;
&lt;p&gt;On 32-bit platforms, intptr_t is int32_t.&lt;/p&gt;
&lt;p&gt;On 64-bit platforms, intptr_t is int64_t.&lt;/p&gt;
&lt;p&gt;intptr_t also comes in a uintptr_t flavor.&lt;/p&gt;
&lt;p&gt;For holding pointer offsets, we have the aptly named ptrdiff_t which is the proper type for storing values of subtracted pointers.&lt;/p&gt;
&lt;p&gt;Maximum Value Holders&lt;/p&gt;
&lt;p&gt;Do you need an integer type capable of holding any integer usable on your system?&lt;/p&gt;
&lt;p&gt;People tend to use the largest known type in this case, such as casting smaller unsigned types to uint64_t, but there's a more technically correct way to guarantee any value can hold any other value.&lt;/p&gt;
&lt;p&gt;The safest container for any integer is intmax_t (also uintmax_t). You can assign or cast any signed integer to intmax_t with no loss of precision, and you can assign or cast any unsigned integer to uintmax_t with no loss of precision.&lt;/p&gt;
&lt;p&gt;That Other Type&lt;/p&gt;
&lt;p&gt;The most widely used system-dependent type is size_t.&lt;/p&gt;
&lt;p&gt;size_t is defined as "an integer capable of holding the largest array index" which also means it's capable of holding the largest memory offset in your program.&lt;/p&gt;
&lt;p&gt;In practical use, size_t is the return type of sizeof operator.&lt;/p&gt;
&lt;p&gt;In either case: size_t is practically defined to be the same as uintptr_t on all modern platforms, so on a 32-bit platform size_t is uint32_t and on a 64-bit platform size_t is uint64_t.&lt;/p&gt;
&lt;p&gt;There is also ssize_t which is a signed size_t used as the return value from library functions that return -1 on error. (Note: ssize_t is POSIX so does not apply to Windows interfaces.)&lt;/p&gt;
&lt;p&gt;So, should you use size_t for arbitrary system-dependent sizes in your own function parameters? Technically, size_t is the return type of sizeof, so any functions accepting a size value representing a number of bytes is allowed to be a size_t.&lt;/p&gt;
&lt;p&gt;Other uses include: size_t is the type of the argument to malloc, and ssize_t is the return type of read() and write() (except on Windows where ssize_t doesn't exist and the return values are just int).&lt;/p&gt;
&lt;p&gt;Printing Types&lt;/p&gt;
&lt;p&gt;You should never cast types during printing. You should use proper type specifiers.&lt;/p&gt;
&lt;p&gt;These include, but are not limited to:&lt;/p&gt;
&lt;p&gt;size_t - %zu
ssize_t - %zd
ptrdiff_t - %td
raw pointer value - %p (prints hex in modern compilers; cast your pointer to (void &lt;em&gt;) first)
64-bit types should be printed using PRIu64 (unsigned) and PRId64 (signed)
on some platforms a 64-bit value is a long and on others it's a long long
it is actually impossible to specify a correct cross-platform format string without these format macros because the types change out from under you (and remember, casting values before printing is not safe or logical).
intptr_t — "%" PRIdPTR
uintptr_t — "%" PRIuPTR
intmax_t — "%" PRIdMAX
uintmax_t — "%" PRIuMAX
One note about the PRI&lt;/em&gt; formatting specifiers: they are macros and the macros expand to proper printf type specifiers on a platform-specific basis. This means you can't do:&lt;/p&gt;
&lt;p&gt;printf("Local number: %PRIdPTR\n\n", someIntPtr);
but instead, because they are macros, you do:&lt;/p&gt;
&lt;p&gt;printf("Local number: %" PRIdPTR "\n\n", someIntPtr);
Notice you put the % inside your format string literal, but the type specifier is outside your format string literal because all adjacent strings get concatentated by the preprocessor into one final combined string literal.&lt;/p&gt;
&lt;p&gt;C99 allows variable declarations anywhere
So, do NOT do this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;do THIS instead:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Caveat: if you have tight loops, test the placement of your initializers. Sometimes scattered declarations can cause unexpected slowdowns. For regular non-fast-path code (which is most of everything in the world), it's best to be as clear as possible, and defining types next to your initializations is a big readability improvement.&lt;/p&gt;
&lt;p&gt;C99 allows for loops to declare counters inline
So, do NOT do this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Do THIS instead:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;One exception: if you need to retain your counter value after the loop exits, obviously don't declare your counter scoped to the loop itself.&lt;/p&gt;
&lt;p&gt;Modern compilers support #pragma once
So, do NOT do this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#ifndef PROJECT_HEADERNAME&lt;/span&gt;
&lt;span class="cp"&gt;#define PROJECT_HEADERNAME&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="cp"&gt;#endif &lt;/span&gt;&lt;span class="cm"&gt;/* PROJECT_HEADERNAME */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Do THIS instead:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#pragma once&lt;/span&gt;
&lt;span class="c"&gt;#pragma once tells the compiler to only include your header once and you do not need three lines of header guards anymore. This pragma is widely supported across all compilers across all platforms and is recommended over manually naming header guards.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;For more details, see list of supported compilers at pragma once.&lt;/p&gt;
&lt;p&gt;C allows static initialization of auto-allocated arrays
So, do NOT do this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;memset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Do THIS instead:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;C allows static initialization of auto-allocated structs
So, do NOT do this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;thing&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;uint64_t&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;thing&lt;/span&gt; &lt;span class="n"&gt;localThing&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;initThing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;memset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;localThing&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;localThing&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Do THIS instead:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;thing&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;uint64_t&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;thing&lt;/span&gt; &lt;span class="n"&gt;localThing&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;IMPORTANT NOTE: If your struct has padding, the {0} method does not zero out extra padding bytes. For example, struct thing has 4 bytes of padding after counter (on a 64-bit platform) because structs are padded to word-sized increments. If you need to zero out an entire struct including unused padding, use memset(&amp;amp;localThing, 0, sizeof(localThing)) because sizeof(localThing) == 16 bytes even though the addressable contents is only 8 + 4 = 12 bytes.&lt;/p&gt;
&lt;p&gt;If you need to re-initialize already allocated structs, declare a global zero-struct for later assignment:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;thing&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;uint64_t&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;thing&lt;/span&gt; &lt;span class="n"&gt;localThingNull&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;thing&lt;/span&gt; &lt;span class="n"&gt;localThing&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{.&lt;/span&gt;&lt;span class="n"&gt;counter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;localThing&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;localThingNull&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If you are lucky enough to be in a C99 (or newer) environment, you can use compound literals instead of keeping a global "zero struct" around (also see, from 2001, The New C: Compound Literals).&lt;/p&gt;
&lt;p&gt;Compound literals allow you to directly assign from anyonomus structs:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;localThing&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;thing&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;C99 added variable length arrays (C11 made them optional)
So, do NOT do this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;uintmax_t&lt;/span&gt; &lt;span class="n"&gt;arrayLength&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;strtoumax&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[];&lt;/span&gt;

&lt;span class="n"&gt;array&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;arrayLength&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="cm"&gt;/* remember to free(array) when you&amp;#39;re done using it */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Do THIS instead:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;uintmax_t&lt;/span&gt; &lt;span class="n"&gt;arrayLength&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;strtoumax&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;arrayLength&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="cm"&gt;/* no need to free array */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;IMPORTANT CAVEAT: variable length arrays are (usually) stack allocated just like regular arrays. If you wouldn't create a 3 million element regular array statically, don't attempt to create a 3 million element array at runtime using this syntax. These are not scalable python/ruby auto-growing lists. If you specify a runtime array length and the length is too big for your stack, your program will do awful things (crashes, security issues). Variable Length Arrays are convienient for small, single-purpose situations, but should not be relied on at scale in production software. If sometimes you need a 3 element array and other times a 3 million element array, definitely do not use the variable length array capability.&lt;/p&gt;
&lt;p&gt;It's good to be aware of the VLA syntax in case you encounter it live (or want it for quick one-off testing), but it can almost be considered a dangerous anti-pattern since you can crash your programs fairly simple by forgetting element size bounds checks or by forgetting you are on a strange target platform with no free stack space.&lt;/p&gt;
&lt;p&gt;NOTE: You must be certain arrayLength is a reasonable size in this situation. (i.e. less than a few KB, sometime your stack will max out at 4 KB on weird platforms). You can't stack allocate huge arrays (millions of entries), but if you know you have a limited count, it's much easier to use C99 VLA capabilities rather than manually requesting heap memory from malloc.&lt;/p&gt;
&lt;p&gt;DOUBLE NOTE: there is no user input checking above, so the user can easily kill your program by allocating a giant VLA. Some people go as far to call VLAs an anti-pattern, but if you keep your bounds tight, it can be a tiny win in certain situations.&lt;/p&gt;
&lt;p&gt;C99 allows annotating non-overlapping pointer parameters
See the restrict keyword (often __restrict)&lt;/p&gt;
&lt;p&gt;Parameter Types
If a function accepts arbitrary input data and a length to process, don't restrict the type of the parameter.&lt;/p&gt;
&lt;p&gt;So, do NOT do this:&lt;/p&gt;
&lt;p&gt;void processAddBytesOverflow(uint8_t *bytes, uint32_t len) {
    for (uint32_t i = 0; i &amp;lt; len; i++) {
        bytes[0] += bytes[i];
    }
}
Do THIS instead:&lt;/p&gt;
&lt;p&gt;void processAddBytesOverflow(void &lt;em&gt;input, uint32_t len) {
    uint8_t &lt;/em&gt;bytes = input;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;bytes&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;bytes&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}
The input types to your functions describe the interface to your code, not what your code is doing with the parameters. The interface to the code above means "accept a byte array and a length", so you don't want to restrict your callers to only uint8_t byte streams. Maybe your users even want to pass in old-style char * values or something else unexpected.&lt;/p&gt;
&lt;p&gt;By declaring your input type as void * then re-assigning or re-casting to the actual type you want inside your function, you save the users of your function from having to think about abstractions inside your own library.&lt;/p&gt;
&lt;p&gt;Some readers have pointed out alignment problems with this example, but we are accessing single byte elements of the input, so everything is fine. If instead we were casting the input to wider types, we would need to watch out for alignment issues. For a different write up dealing with cross-platform alignment issues, see Unaligned Memory Access. (reminder: this page of generic overview details isn't about cross-architecture intricacies of C, so external knowledge and experience is expected to fully use any examples provided.)&lt;/p&gt;
&lt;p&gt;Return Parameter Types
C99 gives us the power of &lt;stdbool.h&gt; which defines true to 1 and false to 0.&lt;/p&gt;
&lt;p&gt;For success/failure return values, functions should return true or false, not an int32_t return type with manually specifying 1 and 0 (or worse, 1 and -1 (or is it 0 success and 1 failure? or is it 0 success and -1 failure?)).&lt;/p&gt;
&lt;p&gt;If a function mutates an input parameter to the extent the parameter is invalidated, instead of returning the altered pointer, your entire API should force double pointers as parameters anywhere an input can be invalidated. Coding with "for some calls, the return value invalidates the input" is too error prone for mass usage.&lt;/p&gt;
&lt;p&gt;So, do NOT do this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;growthOptional&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;grow&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;currentLen&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;newLen&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;newLen&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;currentLen&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;newGrow&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;realloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;grow&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;newLen&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;newGrow&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="cm"&gt;/* resize success */&lt;/span&gt;
            &lt;span class="n"&gt;grow&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newGrow&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="cm"&gt;/* resize failed, free existing and signal failure through NULL */&lt;/span&gt;
            &lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;grow&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;grow&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;grow&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Do THIS instead:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* Return value:&lt;/span&gt;
&lt;span class="cm"&gt; *  - &amp;#39;true&amp;#39; if newLen &amp;gt; currentLen and attempted to grow&lt;/span&gt;
&lt;span class="cm"&gt; *    - &amp;#39;true&amp;#39; does not signify success here, the success is still in &amp;#39;*_grow&amp;#39;&lt;/span&gt;
&lt;span class="cm"&gt; *  - &amp;#39;false&amp;#39; if newLen &amp;lt;= currentLen */&lt;/span&gt;
&lt;span class="n"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;growthOptional&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;_grow&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;currentLen&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;newLen&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;grow&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;_grow&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;newLen&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;currentLen&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;newGrow&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;realloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;grow&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;newLen&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;newGrow&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="cm"&gt;/* resize success */&lt;/span&gt;
            &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;_grow&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newGrow&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="cm"&gt;/* resize failure */&lt;/span&gt;
        &lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;grow&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;_grow&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="cm"&gt;/* for this function,&lt;/span&gt;
&lt;span class="cm"&gt;         * &amp;#39;true&amp;#39; doesn&amp;#39;t mean success, it means &amp;#39;attempted grow&amp;#39; */&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Or, even better, Do THIS instead:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;growthResult&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;GROWTH_RESULT_SUCCESS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;GROWTH_RESULT_FAILURE_GROW_NOT_NECESSARY&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;GROWTH_RESULT_FAILURE_ALLOCATION_FAILED&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;growthResult&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;growthResult&lt;/span&gt; &lt;span class="nf"&gt;growthOptional&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;_grow&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;currentLen&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;newLen&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;grow&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;_grow&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;newLen&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;currentLen&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;newGrow&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;realloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;grow&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;newLen&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;newGrow&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="cm"&gt;/* resize success */&lt;/span&gt;
            &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;_grow&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newGrow&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;GROWTH_RESULT_SUCCESS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="cm"&gt;/* resize failure, don&amp;#39;t remove data because we can signal error */&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;GROWTH_RESULT_FAILURE_ALLOCATION_FAILED&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;GROWTH_RESULT_FAILURE_GROW_NOT_NECESSARY&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Formatting
Coding style is simultaneously very important and utterly worthless.&lt;/p&gt;
&lt;p&gt;If your project has a 50 page coding style guideline, nobody will help you. But, if your code isn't readable, nobody will want to help you.&lt;/p&gt;
&lt;p&gt;The solution here is to always use an automated code formatter.&lt;/p&gt;
&lt;p&gt;The only usable C formatter as of 2016 is clang-format. clang-format has the best defaults of any automatic C formatter and is still actively developed.&lt;/p&gt;
&lt;p&gt;Here's my preferred script to run clang-format with good parameters:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#!/usr/bin/env bash&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;clang-format -style="{BasedOnStyle: llvm, IndentWidth: 4, AllowShortFunctionsOnASingleLine: None, KeepEmptyLinesAtTheStartOfBlocks: false}" "$@"
Then call it as (assuming you named the script cleanup-format):&lt;/p&gt;
&lt;p&gt;matt@foo:~/repos/badcode% cleanup-format -i *.{c,h,cc,cpp,hpp,cxx}
The -i option overwrites existing files in place with formatting changes instead of writing to new files or creating backup files.&lt;/p&gt;
&lt;p&gt;If you have many files, you can recursively process an entire source tree in parallel:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#!/usr/bin/env bash&lt;/span&gt;

&lt;span class="c"&gt;# note: clang-tidy only accepts one file at a time, but we can run it&lt;/span&gt;
&lt;span class="c"&gt;#       parallel against disjoint collections at once.&lt;/span&gt;
find . &lt;span class="se"&gt;\(&lt;/span&gt; -name &lt;span class="se"&gt;\*&lt;/span&gt;.c -or -name &lt;span class="se"&gt;\*&lt;/span&gt;.cpp -or -name &lt;span class="se"&gt;\*&lt;/span&gt;.cc &lt;span class="se"&gt;\)&lt;/span&gt; |xargs -n1 -P4 cleanup-tidy

&lt;span class="c"&gt;# clang-format accepts multiple files during one run, but let&amp;#39;s limit it to 12&lt;/span&gt;
&lt;span class="c"&gt;# here so we (hopefully) avoid excessive memory usage.&lt;/span&gt;
find . &lt;span class="se"&gt;\(&lt;/span&gt; -name &lt;span class="se"&gt;\*&lt;/span&gt;.c -or -name &lt;span class="se"&gt;\*&lt;/span&gt;.cpp -or -name &lt;span class="se"&gt;\*&lt;/span&gt;.cc -or -name &lt;span class="se"&gt;\*&lt;/span&gt;.h &lt;span class="se"&gt;\)&lt;/span&gt; |xargs -n12 -P4 cleanup-format -i
Now, there&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;s a new cleanup-tidy script there. The contents of cleanup-tidy is:

&lt;span class="c"&gt;#!/usr/bin/env bash&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;clang-tidy \
    -fix \
    -fix-errors \
    -header-filter=.* \
    --checks=readability-braces-around-statements,misc-macro-parentheses \
    $1 \
    -- -I.
clang-tidy is policy driven code refactoring tool. The options above enable two fixups:&lt;/p&gt;
&lt;p&gt;readability-braces-around-statements — force all if/while/for statement bodies to be enclosed in braces
It's an accident of history for C to have "brace optional" single statements after loop constructs and conditionals. It is inexcusable to write modern code without braces enforced on every loop and every conditional. Trying to argue "but, the compiler accepts it!" has nothing to do with the readability, maintainability, understandability, or skimability of code. You aren't programming to please your compiler, you are programming to please future people who have to maintain your current brain state years after everybody has forgotten why anything exists in the first place.
misc-macro-parentheses — automatically add parens around all parameters used in macro bodies
clang-tidy is great when it works, but for some complex code bases it can get stuck. Also, clang-tidy doesn't format, so you need to run clang-format after you tidy to align new braces and reflow macros.&lt;/p&gt;
&lt;p&gt;Readability
the writing seems to start slowing down here...&lt;/p&gt;
&lt;p&gt;Comments&lt;/p&gt;
&lt;p&gt;logical self-contained portions of code file&lt;/p&gt;
&lt;p&gt;File Structure&lt;/p&gt;
&lt;p&gt;Try to limit files to a max of 1,000 lines (1,500 lines in really bad cases). If your tests are in-line with your source file (for testing static functions, etc), adjust as necessary.&lt;/p&gt;
&lt;p&gt;misc thoughts
Never use malloc&lt;/p&gt;
&lt;p&gt;You should always use calloc. There is no performance penalty for getting zero'd memory. If you don't like the function protype of calloc(object count, size per object) you can wrap it with #define mycalloc(N) calloc(1, N).&lt;/p&gt;
&lt;p&gt;Readers have commented on a few things here:&lt;/p&gt;
&lt;p&gt;calloc does have a performance impact for huge allocations
calloc does have a performance impact on weird platforms (minimal embedded systems, game consoles, 30 year old hardware, ...)
wrapping calloc(element count, size of each element) is not always a good idea.
a good reason to avoid malloc() is it can't check for integer overflow and is a potential security risk
calloc allocations remove valgrind's ability to warn you about unintentional reads or copies of uninitialized memory since allocations get initialized to 0 automatically
Those are good points, and that's why we always must do performance testing and regression testing for speed across compilers, platforms, operating systems, and hardware devices.&lt;/p&gt;
&lt;p&gt;One advantage of using calloc() directly without a wrapper is, unlike malloc(), calloc() can check for integer overflow because it multiplies its arguments together to obtain your final allocation size. If you are only allocating tiny things, wrapping calloc() is fine. If you are allocating potentially unbounded streams of data, you may want to retain the regular calloc(element count, size of each element) calling convention.&lt;/p&gt;
&lt;p&gt;No advice can be universal, but trying to give exactly perfect generic recommendations would end up reading like a book of language specifications.&lt;/p&gt;
&lt;p&gt;For references on how calloc() gives you clean memory for free, see these nice writeups:&lt;/p&gt;
&lt;p&gt;Benchmarking fun with calloc() and zero pages (2007)
Copy-on-write in virtual memory management
I still stand by my recommendation of always using calloc() for most common scenarios of 2016 (assumption: x64 target platforms, human-sized data, not including human genome-sized data). Any deviations from "expected" drag us into the pit of despair of "domain knowledge," which are words we shan't speak this day.&lt;/p&gt;
&lt;p&gt;Subnote: The pre-zero'd memory delivered to you by calloc() is a one-shot deal. If you realloc() your calloc() allocation, the grown memory extended by realloc is not new zero'd out memory. Your grown allocation is filled with whatever regular uninitialized contents your kernel provides. If you need zero'd memory after a realloc, you must manually memset() the extent of your grown allocation.&lt;/p&gt;
&lt;p&gt;Never memset (if you can avoid it)&lt;/p&gt;
&lt;p&gt;Never memset(ptr, 0, len) when you can statically initialize a structure (or array) to zero (or reset it back to zero by assigning from an in-line compound literal or by assigning from a global zero'd out structure).&lt;/p&gt;
&lt;p&gt;Though, memset() is your only choice if you need to zero out a struct including its padding bytes (because {0} only sets defined fields, not undefined offsets filled by padding).&lt;/p&gt;
&lt;p&gt;Learn More
Also see Fixed width integer types (since C99)&lt;/p&gt;
&lt;p&gt;Also see Apple's Making Code 64-Bit Clean&lt;/p&gt;
&lt;p&gt;Also see the sizes of C types across architectures — unless you keep that entire table in your head for every line of code you write, you should use explicitly defined integer widths and never use char/short/int/long built-in storage types.&lt;/p&gt;
&lt;p&gt;Also see size_t and ptrdiff_t&lt;/p&gt;
&lt;p&gt;Also see Secure Coding. If you really want to write everything perfectly, simply memorize their thousand simple examples.&lt;/p&gt;
&lt;p&gt;Also see Modern C by Jens Gustedt at Inria.&lt;/p&gt;
&lt;p&gt;Closing
Writing correct code at scale is essentially impossible. We have multiple operating systems, runtimes, libraries, and hardware platforms to worry about without even considering things like random bit flips in RAM or our block devices lying to us with unknown probability.&lt;/p&gt;
&lt;p&gt;The best we can do is write simple, understandable code with as few indirections and as little undocumented magic as possible.&lt;/p&gt;
&lt;p&gt;-Matt — @mattsta — ?mattsta&lt;/p&gt;
&lt;p&gt;Attributions
This made the twitter and HN rounds, so many people helpfully pointed out flaws or biased thoughts I'm promulgating here.&lt;/p&gt;
&lt;p&gt;First up, Jeremy Faller and Sos Sosowski and Martin Heistermann and a few other people were kind enough to point out my memset() example was broken and provided the proper fix.&lt;/p&gt;
&lt;p&gt;Martin Heistermann also pointed out the localThing = localThingNull example was broken.&lt;/p&gt;
&lt;p&gt;The opening quote about not writing C if you can avoid it is from the wise internet sage @badboy_.&lt;/p&gt;
&lt;p&gt;Remi Gacogne pointed out I forgot -Wextra.&lt;/p&gt;
&lt;p&gt;Levi Pearson pointed out gcc-5 defaults to gnu11 instead of c89 as well as clarifying the default clang mode.&lt;/p&gt;
&lt;p&gt;Christopher pointed out the -O2 vs -O3 section could use a little more clarification.&lt;/p&gt;
&lt;p&gt;Chad Miller pointed out I was being lazy in the clang-format script params.&lt;/p&gt;
&lt;p&gt;Many people also pointed out the calloc() advice isn't always a good idea if you have extreme circumstances or non-standard hardware (examples of bad ideas: huge allocations, allocations on embedded jiggers, allocations on 30 year old hardware, etc).&lt;/p&gt;
&lt;p&gt;Charles Randolph pointed out I misspelled the world "Building."&lt;/p&gt;
&lt;p&gt;Sven Neuhaus pointed out kindly I also do not posess the ability to spell "initialization" or "initializers." (and also pointed out I misspelled "initialization" wrong the first time here as well)&lt;/p&gt;
&lt;p&gt;Colm MacCárthaigh pointed out I forgot to mention #pragma once.&lt;/p&gt;
&lt;p&gt;Jeffrey Yasskin pointed out we should kill strict aliasing too (mainly a gcc optimization).&lt;/p&gt;
&lt;p&gt;Jeffery Yasskin also provided better wording around the -fno-strict-aliasing section.&lt;/p&gt;
&lt;p&gt;Chris Palmer and a few others pointed out calloc-vs-malloc parameter advantages and the overall drawback of writing a wrapper for calloc() because calloc() provides a more secure interface than malloc() in the first place.&lt;/p&gt;
&lt;p&gt;Damien Sorresso pointed out we should remind people realloc() doesn't zero out grown memory after an initial zero'd calloc() request.&lt;/p&gt;
&lt;p&gt;Pat Pogson pointed out I was unable to spell the word "declare" correctly as well.&lt;/p&gt;
&lt;p&gt;@TopShibe pointed out the stack-allocated initialization example was wrong because the examples I gave were global variables. Updated wording to just mean "auto-allocated" things, be it stack or data sections.&lt;/p&gt;
&lt;p&gt;Jonathan Grynspan suggested harsher wording around the VLA example because they are dangerous when used incorrectly.&lt;/p&gt;
&lt;p&gt;David O'Mahony kindly pointed out I can't spell "specify" either.&lt;/p&gt;
&lt;p&gt;Dr. David Alan Gilbert pointed out ssize_t is a POSIXism and Windows either doesn't have it or defines ssize_t as an unsigned quantity which obviously introduces all kinds of fun behavior when your type is signed on POSIX platforms and unsigned on Windows.&lt;/p&gt;
&lt;p&gt;Chris Ridd suggested we explicitly mention C99 is C from 1999 and C11 is C from 2011 because otherwise it looks strange having 11 be newer than 99.&lt;/p&gt;
&lt;p&gt;Chris Ridd also noticed the clang-format example used unclear naming conventions and suggested better consistency across examples.&lt;/p&gt;
&lt;p&gt;Anthony Le Goff pointed us to a book-length treatment of many modern C ideas called Modern C.&lt;/p&gt;
&lt;p&gt;Stuart Popejoy pointed out my inaccurate spelling of deliberately was truly inaccurate.&lt;/p&gt;
&lt;p&gt;jack rosen pointed out my usage of the word 'exists' does not mean 'exits' as I intended.&lt;/p&gt;
&lt;p&gt;Jo Booth pointed out I like to spell compatibility as compatability, which seems more logical, but English commonality disagrees.&lt;/p&gt;
&lt;p&gt;Stephen Anderson decoded my aberrant spelling of 'stil' back into 'still.'&lt;/p&gt;
&lt;p&gt;Richard Weinberger pointed out struct initialization with {0} doesn't zero out padding bytes, so sending a {0} struct over the wire can leak unintended bytes on under-specified structs.&lt;/p&gt;
&lt;p&gt;@JayBhukhanwala pointed out the function comment in Return Parameter Types was inaccurate because I didn't update the comment when the code changed (story of our lives, right?).&lt;/p&gt;
&lt;p&gt;Lorenzo pointed out we should explicitly provide a warning concerning potential cross-platform alignment issues in section Parameter Types.&lt;/p&gt;
&lt;p&gt;Paolo G. Giarrusso re-clarified the alignment warning I previously added to be more correct regarding the examples given.&lt;/p&gt;
&lt;p&gt;Fabian Kl?tzl provided the valid struct compound literal assignment example since it's perfectly valid syntax I just hadn't run across before.&lt;/p&gt;
&lt;p&gt;Omkar Ekbote provided a very thorough walkthrough of typos and consistency problems here including that I couldn't spell "platform," "actually," "defining," "experience," "simultaneously," "readability," as well as noted some other unclear wordings.&lt;/p&gt;
&lt;p&gt;Carlo Bellettini fixed my aberrant spelling of the word aberrant.&lt;/p&gt;
&lt;p&gt;Keith S Thompson provided many technical corrections in his great article how-to-c-response.&lt;/p&gt;
&lt;p&gt;Many people on reddit went apeshit because this article originally had #import somewhere by mistake. Sorry, crazy people, but this started out as an unedited and unreviewed year old draft when originally pushed live. The error has since been remedied.&lt;/p&gt;
&lt;p&gt;Some people also pointed out the static initialization example uses globals which are always initialized to zero by default anyway (and that they aren't even initialized, they are statically allocated). This is a poor choice of example on my part, but the concepts still stand for typical usage within function scopes. The examples were meant to be any generic "code snippet" and not necessarily top level globals.&lt;/p&gt;
&lt;p&gt;A few people seem to have read this as an "I hate C" page, but it isn't. C is dangerous in the wrong hands (not enough testing, not enough experience when widely deployed), so paradoxically the two kinds of C developers should only be novice hobbyists (code failure causes no problems, it's just a toy) or people who are willing to test their asses off (code failure causes life or financial loss, it's not just a toy) should be writting C code for production usage. There's not much room for "casual observer C development." For the rest of the world, that's why we have Erlang.&lt;/p&gt;
&lt;p&gt;Many people have also mentioned their own pet issues as well or issues beyond the scope of this article (including new C11 only features like George Makrydakis reminding us about C11 generic abilities).&lt;/p&gt;
&lt;p&gt;Perhaps another article about "Practical C" will show up to cover testing, profiling, performance tracing, optional-but-useful warning levels, etc.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">muou</dc:creator><pubDate>Mon, 11 Jan 2016 23:00:00 +0800</pubDate><guid>tag:muou55555.github.com,2016-01-11:content/articles/2016/01/11/howtoc/</guid><category>C</category></item><item><title>基于python开发TerminalTool</title><link>https://muou55555.github.com/content/articles/2016/01/11/TerminalTool/</link><description>&lt;h2&gt;项目概述&lt;/h2&gt;
&lt;p&gt;基于python语言开发，表格式终端命令菜单，会在此菜单上添加嵌入式开发中经常用到的工具类方法。目前按业务控制功能、视图、通用包进行分类。
目前此项目已开源，开源地址访问：&lt;br /&gt;
&lt;br&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;&lt;a href="https://github.com/muou55555/TerminalTool"&gt;https://github.com/muou55555/TerminalTool&lt;/a&gt;   &lt;/p&gt;
&lt;h3&gt;一、pytable&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;功能说明&lt;/code&gt;：表格类，支持按行增加内容；支持多列；支持缺省列时补空；运行是否显示表格标题&lt;/p&gt;
&lt;h4&gt;1.1 使用方法&lt;/h4&gt;
&lt;p&gt;1、初始化pytable&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Pytable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Table Title&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2、显示表标题&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_table_header&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3、添加行数据&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_row_data&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1 - Home&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;2 - Telnet&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;3 - SSH&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;4、显示表格&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;二、pymenu&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;功能说明&lt;/code&gt;：表格菜单类，支持按行增加内容；支持多列；支持缺省列时补空；支持多级子菜单；支持退出确认机制；支持自定义菜单功能实现&lt;/p&gt;
&lt;h4&gt;2.1 使用方法&lt;/h4&gt;
&lt;p&gt;1、初始化pymenu&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;main_menu&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Pymenu&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Main Menu&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;back_key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;q&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2、添加行数据&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;main_menu&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_field&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Telnet&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Telnet&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;main_menu&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_field&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;4&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;SSH&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fun_test&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;main_menu&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_field&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;b&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;sub b&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3、显示菜单&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;main_menu&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;DEMO界面&lt;/h3&gt;
&lt;p&gt;pymenu和pytable界面
&lt;img alt="TerminalToolExample.png" src="/images/Python/TerminalToolExample.png" /&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">muou</dc:creator><pubDate>Mon, 11 Jan 2016 15:32:00 +0800</pubDate><guid>tag:muou55555.github.com,2016-01-11:content/articles/2016/01/11/TerminalTool/</guid><category>Python</category></item><item><title>Learning links</title><link>https://muou55555.github.com/content/articles/2016/01/10/Study/</link><description>&lt;p&gt;&lt;a href="http://www.embeddedlog.com"&gt;http://www.embeddedlog.com&lt;/a&gt;&lt;br&gt;&lt;br&gt;
&lt;a href="http://kentwills.github.io"&gt;http://kentwills.github.io&lt;/a&gt;&lt;br&gt;&lt;br&gt;
&lt;a href="http://rjweiss.github.io"&gt;http://rjweiss.github.io&lt;/a&gt;&lt;br&gt;&lt;br&gt;
&lt;a href="https://github.com/DandyDev"&gt;https://github.com/DandyDev&lt;/a&gt;&lt;br&gt;&lt;br&gt;
&lt;a href="http://www.oschina.net"&gt;oschina&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">muou</dc:creator><pubDate>Sun, 10 Jan 2016 10:20:00 +0800</pubDate><guid>tag:muou55555.github.com,2016-01-10:content/articles/2016/01/10/Study/</guid><category>Study</category></item></channel></rss>